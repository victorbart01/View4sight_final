(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["static/chunks/node_modules_2d131b._.js", {

"[project]/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
/**
 * @license React
 * react-jsx-dev-runtime.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
"production" !== ("TURBOPACK compile-time value", "development") && function() {
    function getComponentNameFromType(type) {
        if (null == type) return null;
        if ("function" === typeof type) return type.$$typeof === REACT_CLIENT_REFERENCE$2 ? null : type.displayName || type.name || null;
        if ("string" === typeof type) return type;
        switch(type){
            case REACT_FRAGMENT_TYPE:
                return "Fragment";
            case REACT_PORTAL_TYPE:
                return "Portal";
            case REACT_PROFILER_TYPE:
                return "Profiler";
            case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
            case REACT_SUSPENSE_TYPE:
                return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
        }
        if ("object" === typeof type) switch("number" === typeof type.tag && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof){
            case REACT_CONTEXT_TYPE:
                return (type.displayName || "Context") + ".Provider";
            case REACT_CONSUMER_TYPE:
                return (type._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
                var innerType = type.render;
                type = type.displayName;
                type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
                return type;
            case REACT_MEMO_TYPE:
                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE:
                innerType = type._payload;
                type = type._init;
                try {
                    return getComponentNameFromType(type(innerType));
                } catch (x) {}
        }
        return null;
    }
    function testStringCoercion(value) {
        return "" + value;
    }
    function checkKeyStringCoercion(value) {
        try {
            testStringCoercion(value);
            var JSCompiler_inline_result = !1;
        } catch (e) {
            JSCompiler_inline_result = !0;
        }
        if (JSCompiler_inline_result) {
            JSCompiler_inline_result = console;
            var JSCompiler_temp_const = JSCompiler_inline_result.error;
            var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            JSCompiler_temp_const.call(JSCompiler_inline_result, "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.", JSCompiler_inline_result$jscomp$0);
            return testStringCoercion(value);
        }
    }
    function disabledLog() {}
    function disableLogs() {
        if (0 === disabledDepth) {
            prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd;
            var props = {
                configurable: !0,
                enumerable: !0,
                value: disabledLog,
                writable: !0
            };
            Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
            });
        }
        disabledDepth++;
    }
    function reenableLogs() {
        disabledDepth--;
        if (0 === disabledDepth) {
            var props = {
                configurable: !0,
                enumerable: !0,
                writable: !0
            };
            Object.defineProperties(console, {
                log: assign({}, props, {
                    value: prevLog
                }),
                info: assign({}, props, {
                    value: prevInfo
                }),
                warn: assign({}, props, {
                    value: prevWarn
                }),
                error: assign({}, props, {
                    value: prevError
                }),
                group: assign({}, props, {
                    value: prevGroup
                }),
                groupCollapsed: assign({}, props, {
                    value: prevGroupCollapsed
                }),
                groupEnd: assign({}, props, {
                    value: prevGroupEnd
                })
            });
        }
        0 > disabledDepth && console.error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
    }
    function describeBuiltInComponentFrame(name) {
        if (void 0 === prefix) try {
            throw Error();
        } catch (x) {
            var match = x.stack.trim().match(/\n( *(at )?)/);
            prefix = match && match[1] || "";
            suffix = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
        }
        return "\n" + prefix + name + suffix;
    }
    function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry) return "";
        var frame = componentFrameCache.get(fn);
        if (void 0 !== frame) return frame;
        reentry = !0;
        frame = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var previousDispatcher = null;
        previousDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = null;
        disableLogs();
        try {
            var RunInRootFrame = {
                DetermineComponentFrameRoot: function() {
                    try {
                        if (construct) {
                            var Fake = function() {
                                throw Error();
                            };
                            Object.defineProperty(Fake.prototype, "props", {
                                set: function() {
                                    throw Error();
                                }
                            });
                            if ("object" === typeof Reflect && Reflect.construct) {
                                try {
                                    Reflect.construct(Fake, []);
                                } catch (x) {
                                    var control = x;
                                }
                                Reflect.construct(fn, [], Fake);
                            } else {
                                try {
                                    Fake.call();
                                } catch (x$0) {
                                    control = x$0;
                                }
                                fn.call(Fake.prototype);
                            }
                        } else {
                            try {
                                throw Error();
                            } catch (x$1) {
                                control = x$1;
                            }
                            (Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function() {});
                        }
                    } catch (sample) {
                        if (sample && control && "string" === typeof sample.stack) return [
                            sample.stack,
                            control.stack
                        ];
                    }
                    return [
                        null,
                        null
                    ];
                }
            };
            RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
            var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, "name");
            namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, "name", {
                value: "DetermineComponentFrameRoot"
            });
            var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
            if (sampleStack && controlStack) {
                var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
                for(_RunInRootFrame$Deter = namePropDescriptor = 0; namePropDescriptor < sampleLines.length && !sampleLines[namePropDescriptor].includes("DetermineComponentFrameRoot");)namePropDescriptor++;
                for(; _RunInRootFrame$Deter < controlLines.length && !controlLines[_RunInRootFrame$Deter].includes("DetermineComponentFrameRoot");)_RunInRootFrame$Deter++;
                if (namePropDescriptor === sampleLines.length || _RunInRootFrame$Deter === controlLines.length) for(namePropDescriptor = sampleLines.length - 1, _RunInRootFrame$Deter = controlLines.length - 1; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter && sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter];)_RunInRootFrame$Deter--;
                for(; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter; namePropDescriptor--, _RunInRootFrame$Deter--)if (sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                    if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {
                        do if (namePropDescriptor--, _RunInRootFrame$Deter--, 0 > _RunInRootFrame$Deter || sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                            var _frame = "\n" + sampleLines[namePropDescriptor].replace(" at new ", " at ");
                            fn.displayName && _frame.includes("<anonymous>") && (_frame = _frame.replace("<anonymous>", fn.displayName));
                            "function" === typeof fn && componentFrameCache.set(fn, _frame);
                            return _frame;
                        }
                        while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter)
                    }
                    break;
                }
            }
        } finally{
            reentry = !1, ReactSharedInternals.H = previousDispatcher, reenableLogs(), Error.prepareStackTrace = frame;
        }
        sampleLines = (sampleLines = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(sampleLines) : "";
        "function" === typeof fn && componentFrameCache.set(fn, sampleLines);
        return sampleLines;
    }
    function describeUnknownElementTypeFrameInDEV(type) {
        if (null == type) return "";
        if ("function" === typeof type) {
            var prototype = type.prototype;
            return describeNativeComponentFrame(type, !(!prototype || !prototype.isReactComponent));
        }
        if ("string" === typeof type) return describeBuiltInComponentFrame(type);
        switch(type){
            case REACT_SUSPENSE_TYPE:
                return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
                return describeBuiltInComponentFrame("SuspenseList");
        }
        if ("object" === typeof type) switch(type.$$typeof){
            case REACT_FORWARD_REF_TYPE:
                return type = describeNativeComponentFrame(type.render, !1), type;
            case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type.type);
            case REACT_LAZY_TYPE:
                prototype = type._payload;
                type = type._init;
                try {
                    return describeUnknownElementTypeFrameInDEV(type(prototype));
                } catch (x) {}
        }
        return "";
    }
    function getOwner() {
        var dispatcher = ReactSharedInternals.A;
        return null === dispatcher ? null : dispatcher.getOwner();
    }
    function hasValidKey(config) {
        if (hasOwnProperty.call(config, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config, "key").get;
            if (getter && getter.isReactWarning) return !1;
        }
        return void 0 !== config.key;
    }
    function defineKeyPropWarningGetter(props, displayName) {
        function warnAboutAccessingKey() {
            specialPropKeyWarningShown || (specialPropKeyWarningShown = !0, console.error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)", displayName));
        }
        warnAboutAccessingKey.isReactWarning = !0;
        Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: !0
        });
    }
    function elementRefGetterWithDeprecationWarning() {
        var componentName = getComponentNameFromType(this.type);
        didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = !0, console.error("Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."));
        componentName = this.props.ref;
        return void 0 !== componentName ? componentName : null;
    }
    function ReactElement(type, key, self, source, owner, props) {
        self = props.ref;
        type = {
            $$typeof: REACT_ELEMENT_TYPE,
            type: type,
            key: key,
            props: props,
            _owner: owner
        };
        null !== (void 0 !== self ? self : null) ? Object.defineProperty(type, "ref", {
            enumerable: !1,
            get: elementRefGetterWithDeprecationWarning
        }) : Object.defineProperty(type, "ref", {
            enumerable: !1,
            value: null
        });
        type._store = {};
        Object.defineProperty(type._store, "validated", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: 0
        });
        Object.defineProperty(type, "_debugInfo", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: null
        });
        Object.freeze && (Object.freeze(type.props), Object.freeze(type));
        return type;
    }
    function jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self) {
        if ("string" === typeof type || "function" === typeof type || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_OFFSCREEN_TYPE || "object" === typeof type && null !== type && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE$1 || void 0 !== type.getModuleId)) {
            var children = config.children;
            if (void 0 !== children) if (isStaticChildren) if (isArrayImpl(children)) {
                for(isStaticChildren = 0; isStaticChildren < children.length; isStaticChildren++)validateChildKeys(children[isStaticChildren], type);
                Object.freeze && Object.freeze(children);
            } else console.error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else validateChildKeys(children, type);
        } else {
            children = "";
            if (void 0 === type || "object" === typeof type && null !== type && 0 === Object.keys(type).length) children += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            null === type ? isStaticChildren = "null" : isArrayImpl(type) ? isStaticChildren = "array" : void 0 !== type && type.$$typeof === REACT_ELEMENT_TYPE ? (isStaticChildren = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />", children = " Did you accidentally export a JSX literal instead of a component?") : isStaticChildren = typeof type;
            console.error("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", isStaticChildren, children);
        }
        if (hasOwnProperty.call(config, "key")) {
            children = getComponentNameFromType(type);
            var keys = Object.keys(config).filter(function(k) {
                return "key" !== k;
            });
            isStaticChildren = 0 < keys.length ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
            didWarnAboutKeySpread[children + isStaticChildren] || (keys = 0 < keys.length ? "{" + keys.join(": ..., ") + ": ...}" : "{}", console.error('A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />', isStaticChildren, children, keys, children), didWarnAboutKeySpread[children + isStaticChildren] = !0);
        }
        children = null;
        void 0 !== maybeKey && (checkKeyStringCoercion(maybeKey), children = "" + maybeKey);
        hasValidKey(config) && (checkKeyStringCoercion(config.key), children = "" + config.key);
        if ("key" in config) {
            maybeKey = {};
            for(var propName in config)"key" !== propName && (maybeKey[propName] = config[propName]);
        } else maybeKey = config;
        children && defineKeyPropWarningGetter(maybeKey, "function" === typeof type ? type.displayName || type.name || "Unknown" : type);
        return ReactElement(type, children, self, source, getOwner(), maybeKey);
    }
    function validateChildKeys(node, parentType) {
        if ("object" === typeof node && node && node.$$typeof !== REACT_CLIENT_REFERENCE) {
            if (isArrayImpl(node)) for(var i = 0; i < node.length; i++){
                var child = node[i];
                isValidElement(child) && validateExplicitKey(child, parentType);
            }
            else if (isValidElement(node)) node._store && (node._store.validated = 1);
            else if (null === node || "object" !== typeof node ? i = null : (i = MAYBE_ITERATOR_SYMBOL && node[MAYBE_ITERATOR_SYMBOL] || node["@@iterator"], i = "function" === typeof i ? i : null), "function" === typeof i && i !== node.entries && (i = i.call(node), i !== node)) for(; !(node = i.next()).done;)isValidElement(node.value) && validateExplicitKey(node.value, parentType);
        }
    }
    function isValidElement(object) {
        return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
    }
    function validateExplicitKey(element, parentType) {
        if (element._store && !element._store.validated && null == element.key && (element._store.validated = 1, parentType = getCurrentComponentErrorInfo(parentType), !ownerHasKeyUseWarning[parentType])) {
            ownerHasKeyUseWarning[parentType] = !0;
            var childOwner = "";
            element && null != element._owner && element._owner !== getOwner() && (childOwner = null, "number" === typeof element._owner.tag ? childOwner = getComponentNameFromType(element._owner.type) : "string" === typeof element._owner.name && (childOwner = element._owner.name), childOwner = " It was passed a child from " + childOwner + ".");
            var prevGetCurrentStack = ReactSharedInternals.getCurrentStack;
            ReactSharedInternals.getCurrentStack = function() {
                var stack = describeUnknownElementTypeFrameInDEV(element.type);
                prevGetCurrentStack && (stack += prevGetCurrentStack() || "");
                return stack;
            };
            console.error('Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.', parentType, childOwner);
            ReactSharedInternals.getCurrentStack = prevGetCurrentStack;
        }
    }
    function getCurrentComponentErrorInfo(parentType) {
        var info = "", owner = getOwner();
        owner && (owner = getComponentNameFromType(owner.type)) && (info = "\n\nCheck the render method of `" + owner + "`.");
        info || (parentType = getComponentNameFromType(parentType)) && (info = "\n\nCheck the top-level render call using <" + parentType + ">.");
        return info;
    }
    var React = __turbopack_require__("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
    Symbol.for("react.provider");
    var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, REACT_CLIENT_REFERENCE$2 = Symbol.for("react.client.reference"), ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, hasOwnProperty = Object.prototype.hasOwnProperty, assign = Object.assign, REACT_CLIENT_REFERENCE$1 = Symbol.for("react.client.reference"), isArrayImpl = Array.isArray, disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;
    disabledLog.__reactDisabledLog = !0;
    var prefix, suffix, reentry = !1;
    var componentFrameCache = new ("function" === typeof WeakMap ? WeakMap : Map)();
    var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), specialPropKeyWarningShown;
    var didWarnAboutElementRef = {};
    var didWarnAboutKeySpread = {}, ownerHasKeyUseWarning = {};
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.jsxDEV = function(type, config, maybeKey, isStaticChildren, source, self) {
        return jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self);
    };
}();
}}),
"[project]/node_modules/next/dist/compiled/react/jsx-dev-runtime.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use strict';
if ("TURBOPACK compile-time falsy", 0) {
    "TURBOPACK unreachable";
} else {
    module.exports = __turbopack_require__("[project]/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js [app-client] (ecmascript)");
}
}}),
"[project]/node_modules/animejs/lib/anime.es.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
 * anime.js v3.2.2
 * (c) 2023 Julian Garnier
 * Released under the MIT license
 * animejs.com
 */ // Defaults
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var defaultInstanceSettings = {
    update: null,
    begin: null,
    loopBegin: null,
    changeBegin: null,
    change: null,
    changeComplete: null,
    loopComplete: null,
    complete: null,
    loop: 1,
    direction: 'normal',
    autoplay: true,
    timelineOffset: 0
};
var defaultTweenSettings = {
    duration: 1000,
    delay: 0,
    endDelay: 0,
    easing: 'easeOutElastic(1, .5)',
    round: 0
};
var validTransforms = [
    'translateX',
    'translateY',
    'translateZ',
    'rotate',
    'rotateX',
    'rotateY',
    'rotateZ',
    'scale',
    'scaleX',
    'scaleY',
    'scaleZ',
    'skew',
    'skewX',
    'skewY',
    'perspective',
    'matrix',
    'matrix3d'
];
// Caching
var cache = {
    CSS: {},
    springs: {}
};
// Utils
function minMax(val, min, max) {
    return Math.min(Math.max(val, min), max);
}
function stringContains(str, text) {
    return str.indexOf(text) > -1;
}
function applyArguments(func, args) {
    return func.apply(null, args);
}
var is = {
    arr: function(a) {
        return Array.isArray(a);
    },
    obj: function(a) {
        return stringContains(Object.prototype.toString.call(a), 'Object');
    },
    pth: function(a) {
        return is.obj(a) && a.hasOwnProperty('totalLength');
    },
    svg: function(a) {
        return a instanceof SVGElement;
    },
    inp: function(a) {
        return a instanceof HTMLInputElement;
    },
    dom: function(a) {
        return a.nodeType || is.svg(a);
    },
    str: function(a) {
        return typeof a === 'string';
    },
    fnc: function(a) {
        return typeof a === 'function';
    },
    und: function(a) {
        return typeof a === 'undefined';
    },
    nil: function(a) {
        return is.und(a) || a === null;
    },
    hex: function(a) {
        return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(a);
    },
    rgb: function(a) {
        return /^rgb/.test(a);
    },
    hsl: function(a) {
        return /^hsl/.test(a);
    },
    col: function(a) {
        return is.hex(a) || is.rgb(a) || is.hsl(a);
    },
    key: function(a) {
        return !defaultInstanceSettings.hasOwnProperty(a) && !defaultTweenSettings.hasOwnProperty(a) && a !== 'targets' && a !== 'keyframes';
    }
};
// Easings
function parseEasingParameters(string) {
    var match = /\(([^)]+)\)/.exec(string);
    return match ? match[1].split(',').map(function(p) {
        return parseFloat(p);
    }) : [];
}
// Spring solver inspired by Webkit Copyright © 2016 Apple Inc. All rights reserved. https://webkit.org/demos/spring/spring.js
function spring(string, duration) {
    var params = parseEasingParameters(string);
    var mass = minMax(is.und(params[0]) ? 1 : params[0], .1, 100);
    var stiffness = minMax(is.und(params[1]) ? 100 : params[1], .1, 100);
    var damping = minMax(is.und(params[2]) ? 10 : params[2], .1, 100);
    var velocity = minMax(is.und(params[3]) ? 0 : params[3], .1, 100);
    var w0 = Math.sqrt(stiffness / mass);
    var zeta = damping / (2 * Math.sqrt(stiffness * mass));
    var wd = zeta < 1 ? w0 * Math.sqrt(1 - zeta * zeta) : 0;
    var a = 1;
    var b = zeta < 1 ? (zeta * w0 + -velocity) / wd : -velocity + w0;
    function solver(t) {
        var progress = duration ? duration * t / 1000 : t;
        if (zeta < 1) {
            progress = Math.exp(-progress * zeta * w0) * (a * Math.cos(wd * progress) + b * Math.sin(wd * progress));
        } else {
            progress = (a + b * progress) * Math.exp(-progress * w0);
        }
        if (t === 0 || t === 1) {
            return t;
        }
        return 1 - progress;
    }
    function getDuration() {
        var cached = cache.springs[string];
        if (cached) {
            return cached;
        }
        var frame = 1 / 6;
        var elapsed = 0;
        var rest = 0;
        while(true){
            elapsed += frame;
            if (solver(elapsed) === 1) {
                rest++;
                if (rest >= 16) {
                    break;
                }
            } else {
                rest = 0;
            }
        }
        var duration = elapsed * frame * 1000;
        cache.springs[string] = duration;
        return duration;
    }
    return duration ? solver : getDuration;
}
// Basic steps easing implementation https://developer.mozilla.org/fr/docs/Web/CSS/transition-timing-function
function steps(steps) {
    if (steps === void 0) steps = 10;
    return function(t) {
        return Math.ceil(minMax(t, 0.000001, 1) * steps) * (1 / steps);
    };
}
// BezierEasing https://github.com/gre/bezier-easing
var bezier = function() {
    var kSplineTableSize = 11;
    var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);
    function A(aA1, aA2) {
        return 1.0 - 3.0 * aA2 + 3.0 * aA1;
    }
    function B(aA1, aA2) {
        return 3.0 * aA2 - 6.0 * aA1;
    }
    function C(aA1) {
        return 3.0 * aA1;
    }
    function calcBezier(aT, aA1, aA2) {
        return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
    }
    function getSlope(aT, aA1, aA2) {
        return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
    }
    function binarySubdivide(aX, aA, aB, mX1, mX2) {
        var currentX, currentT, i = 0;
        do {
            currentT = aA + (aB - aA) / 2.0;
            currentX = calcBezier(currentT, mX1, mX2) - aX;
            if (currentX > 0.0) {
                aB = currentT;
            } else {
                aA = currentT;
            }
        }while (Math.abs(currentX) > 0.0000001 && ++i < 10)
        return currentT;
    }
    function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
        for(var i = 0; i < 4; ++i){
            var currentSlope = getSlope(aGuessT, mX1, mX2);
            if (currentSlope === 0.0) {
                return aGuessT;
            }
            var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
            aGuessT -= currentX / currentSlope;
        }
        return aGuessT;
    }
    function bezier(mX1, mY1, mX2, mY2) {
        if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {
            return;
        }
        var sampleValues = new Float32Array(kSplineTableSize);
        if (mX1 !== mY1 || mX2 !== mY2) {
            for(var i = 0; i < kSplineTableSize; ++i){
                sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
            }
        }
        function getTForX(aX) {
            var intervalStart = 0;
            var currentSample = 1;
            var lastSample = kSplineTableSize - 1;
            for(; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample){
                intervalStart += kSampleStepSize;
            }
            --currentSample;
            var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
            var guessForT = intervalStart + dist * kSampleStepSize;
            var initialSlope = getSlope(guessForT, mX1, mX2);
            if (initialSlope >= 0.001) {
                return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
            } else if (initialSlope === 0.0) {
                return guessForT;
            } else {
                return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
            }
        }
        return function(x) {
            if (mX1 === mY1 && mX2 === mY2) {
                return x;
            }
            if (x === 0 || x === 1) {
                return x;
            }
            return calcBezier(getTForX(x), mY1, mY2);
        };
    }
    return bezier;
}();
var penner = function() {
    // Based on jQuery UI's implemenation of easing equations from Robert Penner (http://www.robertpenner.com/easing)
    var eases = {
        linear: function() {
            return function(t) {
                return t;
            };
        }
    };
    var functionEasings = {
        Sine: function() {
            return function(t) {
                return 1 - Math.cos(t * Math.PI / 2);
            };
        },
        Expo: function() {
            return function(t) {
                return t ? Math.pow(2, 10 * t - 10) : 0;
            };
        },
        Circ: function() {
            return function(t) {
                return 1 - Math.sqrt(1 - t * t);
            };
        },
        Back: function() {
            return function(t) {
                return t * t * (3 * t - 2);
            };
        },
        Bounce: function() {
            return function(t) {
                var pow2, b = 4;
                while(t < ((pow2 = Math.pow(2, --b)) - 1) / 11){}
                return 1 / Math.pow(4, 3 - b) - 7.5625 * Math.pow((pow2 * 3 - 2) / 22 - t, 2);
            };
        },
        Elastic: function(amplitude, period) {
            if (amplitude === void 0) amplitude = 1;
            if (period === void 0) period = .5;
            var a = minMax(amplitude, 1, 10);
            var p = minMax(period, .1, 2);
            return function(t) {
                return t === 0 || t === 1 ? t : -a * Math.pow(2, 10 * (t - 1)) * Math.sin((t - 1 - p / (Math.PI * 2) * Math.asin(1 / a)) * (Math.PI * 2) / p);
            };
        }
    };
    var baseEasings = [
        'Quad',
        'Cubic',
        'Quart',
        'Quint'
    ];
    baseEasings.forEach(function(name, i) {
        functionEasings[name] = function() {
            return function(t) {
                return Math.pow(t, i + 2);
            };
        };
    });
    Object.keys(functionEasings).forEach(function(name) {
        var easeIn = functionEasings[name];
        eases['easeIn' + name] = easeIn;
        eases['easeOut' + name] = function(a, b) {
            return function(t) {
                return 1 - easeIn(a, b)(1 - t);
            };
        };
        eases['easeInOut' + name] = function(a, b) {
            return function(t) {
                return t < 0.5 ? easeIn(a, b)(t * 2) / 2 : 1 - easeIn(a, b)(t * -2 + 2) / 2;
            };
        };
        eases['easeOutIn' + name] = function(a, b) {
            return function(t) {
                return t < 0.5 ? (1 - easeIn(a, b)(1 - t * 2)) / 2 : (easeIn(a, b)(t * 2 - 1) + 1) / 2;
            };
        };
    });
    return eases;
}();
function parseEasings(easing, duration) {
    if (is.fnc(easing)) {
        return easing;
    }
    var name = easing.split('(')[0];
    var ease = penner[name];
    var args = parseEasingParameters(easing);
    switch(name){
        case 'spring':
            return spring(easing, duration);
        case 'cubicBezier':
            return applyArguments(bezier, args);
        case 'steps':
            return applyArguments(steps, args);
        default:
            return applyArguments(ease, args);
    }
}
// Strings
function selectString(str) {
    try {
        var nodes = document.querySelectorAll(str);
        return nodes;
    } catch (e) {
        return;
    }
}
// Arrays
function filterArray(arr, callback) {
    var len = arr.length;
    var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
    var result = [];
    for(var i = 0; i < len; i++){
        if (i in arr) {
            var val = arr[i];
            if (callback.call(thisArg, val, i, arr)) {
                result.push(val);
            }
        }
    }
    return result;
}
function flattenArray(arr) {
    return arr.reduce(function(a, b) {
        return a.concat(is.arr(b) ? flattenArray(b) : b);
    }, []);
}
function toArray(o) {
    if (is.arr(o)) {
        return o;
    }
    if (is.str(o)) {
        o = selectString(o) || o;
    }
    if (o instanceof NodeList || o instanceof HTMLCollection) {
        return [].slice.call(o);
    }
    return [
        o
    ];
}
function arrayContains(arr, val) {
    return arr.some(function(a) {
        return a === val;
    });
}
// Objects
function cloneObject(o) {
    var clone = {};
    for(var p in o){
        clone[p] = o[p];
    }
    return clone;
}
function replaceObjectProps(o1, o2) {
    var o = cloneObject(o1);
    for(var p in o1){
        o[p] = o2.hasOwnProperty(p) ? o2[p] : o1[p];
    }
    return o;
}
function mergeObjects(o1, o2) {
    var o = cloneObject(o1);
    for(var p in o2){
        o[p] = is.und(o1[p]) ? o2[p] : o1[p];
    }
    return o;
}
// Colors
function rgbToRgba(rgbValue) {
    var rgb = /rgb\((\d+,\s*[\d]+,\s*[\d]+)\)/g.exec(rgbValue);
    return rgb ? "rgba(" + rgb[1] + ",1)" : rgbValue;
}
function hexToRgba(hexValue) {
    var rgx = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    var hex = hexValue.replace(rgx, function(m, r, g, b) {
        return r + r + g + g + b + b;
    });
    var rgb = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    var r = parseInt(rgb[1], 16);
    var g = parseInt(rgb[2], 16);
    var b = parseInt(rgb[3], 16);
    return "rgba(" + r + "," + g + "," + b + ",1)";
}
function hslToRgba(hslValue) {
    var hsl = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(hslValue) || /hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*([\d.]+)\)/g.exec(hslValue);
    var h = parseInt(hsl[1], 10) / 360;
    var s = parseInt(hsl[2], 10) / 100;
    var l = parseInt(hsl[3], 10) / 100;
    var a = hsl[4] || 1;
    function hue2rgb(p, q, t) {
        if (t < 0) {
            t += 1;
        }
        if (t > 1) {
            t -= 1;
        }
        if (t < 1 / 6) {
            return p + (q - p) * 6 * t;
        }
        if (t < 1 / 2) {
            return q;
        }
        if (t < 2 / 3) {
            return p + (q - p) * (2 / 3 - t) * 6;
        }
        return p;
    }
    var r, g, b;
    if (s == 0) {
        r = g = b = l;
    } else {
        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        var p = 2 * l - q;
        r = hue2rgb(p, q, h + 1 / 3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1 / 3);
    }
    return "rgba(" + r * 255 + "," + g * 255 + "," + b * 255 + "," + a + ")";
}
function colorToRgb(val) {
    if (is.rgb(val)) {
        return rgbToRgba(val);
    }
    if (is.hex(val)) {
        return hexToRgba(val);
    }
    if (is.hsl(val)) {
        return hslToRgba(val);
    }
}
// Units
function getUnit(val) {
    var split = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/.exec(val);
    if (split) {
        return split[1];
    }
}
function getTransformUnit(propName) {
    if (stringContains(propName, 'translate') || propName === 'perspective') {
        return 'px';
    }
    if (stringContains(propName, 'rotate') || stringContains(propName, 'skew')) {
        return 'deg';
    }
}
// Values
function getFunctionValue(val, animatable) {
    if (!is.fnc(val)) {
        return val;
    }
    return val(animatable.target, animatable.id, animatable.total);
}
function getAttribute(el, prop) {
    return el.getAttribute(prop);
}
function convertPxToUnit(el, value, unit) {
    var valueUnit = getUnit(value);
    if (arrayContains([
        unit,
        'deg',
        'rad',
        'turn'
    ], valueUnit)) {
        return value;
    }
    var cached = cache.CSS[value + unit];
    if (!is.und(cached)) {
        return cached;
    }
    var baseline = 100;
    var tempEl = document.createElement(el.tagName);
    var parentEl = el.parentNode && el.parentNode !== document ? el.parentNode : document.body;
    parentEl.appendChild(tempEl);
    tempEl.style.position = 'absolute';
    tempEl.style.width = baseline + unit;
    var factor = baseline / tempEl.offsetWidth;
    parentEl.removeChild(tempEl);
    var convertedUnit = factor * parseFloat(value);
    cache.CSS[value + unit] = convertedUnit;
    return convertedUnit;
}
function getCSSValue(el, prop, unit) {
    if (prop in el.style) {
        var uppercasePropName = prop.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
        var value = el.style[prop] || getComputedStyle(el).getPropertyValue(uppercasePropName) || '0';
        return unit ? convertPxToUnit(el, value, unit) : value;
    }
}
function getAnimationType(el, prop) {
    if (is.dom(el) && !is.inp(el) && (!is.nil(getAttribute(el, prop)) || is.svg(el) && el[prop])) {
        return 'attribute';
    }
    if (is.dom(el) && arrayContains(validTransforms, prop)) {
        return 'transform';
    }
    if (is.dom(el) && prop !== 'transform' && getCSSValue(el, prop)) {
        return 'css';
    }
    if (el[prop] != null) {
        return 'object';
    }
}
function getElementTransforms(el) {
    if (!is.dom(el)) {
        return;
    }
    var str = el.style.transform || '';
    var reg = /(\w+)\(([^)]*)\)/g;
    var transforms = new Map();
    var m;
    while(m = reg.exec(str)){
        transforms.set(m[1], m[2]);
    }
    return transforms;
}
function getTransformValue(el, propName, animatable, unit) {
    var defaultVal = stringContains(propName, 'scale') ? 1 : 0 + getTransformUnit(propName);
    var value = getElementTransforms(el).get(propName) || defaultVal;
    if (animatable) {
        animatable.transforms.list.set(propName, value);
        animatable.transforms['last'] = propName;
    }
    return unit ? convertPxToUnit(el, value, unit) : value;
}
function getOriginalTargetValue(target, propName, unit, animatable) {
    switch(getAnimationType(target, propName)){
        case 'transform':
            return getTransformValue(target, propName, animatable, unit);
        case 'css':
            return getCSSValue(target, propName, unit);
        case 'attribute':
            return getAttribute(target, propName);
        default:
            return target[propName] || 0;
    }
}
function getRelativeValue(to, from) {
    var operator = /^(\*=|\+=|-=)/.exec(to);
    if (!operator) {
        return to;
    }
    var u = getUnit(to) || 0;
    var x = parseFloat(from);
    var y = parseFloat(to.replace(operator[0], ''));
    switch(operator[0][0]){
        case '+':
            return x + y + u;
        case '-':
            return x - y + u;
        case '*':
            return x * y + u;
    }
}
function validateValue(val, unit) {
    if (is.col(val)) {
        return colorToRgb(val);
    }
    if (/\s/g.test(val)) {
        return val;
    }
    var originalUnit = getUnit(val);
    var unitLess = originalUnit ? val.substr(0, val.length - originalUnit.length) : val;
    if (unit) {
        return unitLess + unit;
    }
    return unitLess;
}
// getTotalLength() equivalent for circle, rect, polyline, polygon and line shapes
// adapted from https://gist.github.com/SebLambla/3e0550c496c236709744
function getDistance(p1, p2) {
    return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
}
function getCircleLength(el) {
    return Math.PI * 2 * getAttribute(el, 'r');
}
function getRectLength(el) {
    return getAttribute(el, 'width') * 2 + getAttribute(el, 'height') * 2;
}
function getLineLength(el) {
    return getDistance({
        x: getAttribute(el, 'x1'),
        y: getAttribute(el, 'y1')
    }, {
        x: getAttribute(el, 'x2'),
        y: getAttribute(el, 'y2')
    });
}
function getPolylineLength(el) {
    var points = el.points;
    var totalLength = 0;
    var previousPos;
    for(var i = 0; i < points.numberOfItems; i++){
        var currentPos = points.getItem(i);
        if (i > 0) {
            totalLength += getDistance(previousPos, currentPos);
        }
        previousPos = currentPos;
    }
    return totalLength;
}
function getPolygonLength(el) {
    var points = el.points;
    return getPolylineLength(el) + getDistance(points.getItem(points.numberOfItems - 1), points.getItem(0));
}
// Path animation
function getTotalLength(el) {
    if (el.getTotalLength) {
        return el.getTotalLength();
    }
    switch(el.tagName.toLowerCase()){
        case 'circle':
            return getCircleLength(el);
        case 'rect':
            return getRectLength(el);
        case 'line':
            return getLineLength(el);
        case 'polyline':
            return getPolylineLength(el);
        case 'polygon':
            return getPolygonLength(el);
    }
}
function setDashoffset(el) {
    var pathLength = getTotalLength(el);
    el.setAttribute('stroke-dasharray', pathLength);
    return pathLength;
}
// Motion path
function getParentSvgEl(el) {
    var parentEl = el.parentNode;
    while(is.svg(parentEl)){
        if (!is.svg(parentEl.parentNode)) {
            break;
        }
        parentEl = parentEl.parentNode;
    }
    return parentEl;
}
function getParentSvg(pathEl, svgData) {
    var svg = svgData || {};
    var parentSvgEl = svg.el || getParentSvgEl(pathEl);
    var rect = parentSvgEl.getBoundingClientRect();
    var viewBoxAttr = getAttribute(parentSvgEl, 'viewBox');
    var width = rect.width;
    var height = rect.height;
    var viewBox = svg.viewBox || (viewBoxAttr ? viewBoxAttr.split(' ') : [
        0,
        0,
        width,
        height
    ]);
    return {
        el: parentSvgEl,
        viewBox: viewBox,
        x: viewBox[0] / 1,
        y: viewBox[1] / 1,
        w: width,
        h: height,
        vW: viewBox[2],
        vH: viewBox[3]
    };
}
function getPath(path, percent) {
    var pathEl = is.str(path) ? selectString(path)[0] : path;
    var p = percent || 100;
    return function(property) {
        return {
            property: property,
            el: pathEl,
            svg: getParentSvg(pathEl),
            totalLength: getTotalLength(pathEl) * (p / 100)
        };
    };
}
function getPathProgress(path, progress, isPathTargetInsideSVG) {
    function point(offset) {
        if (offset === void 0) offset = 0;
        var l = progress + offset >= 1 ? progress + offset : 0;
        return path.el.getPointAtLength(l);
    }
    var svg = getParentSvg(path.el, path.svg);
    var p = point();
    var p0 = point(-1);
    var p1 = point(+1);
    var scaleX = isPathTargetInsideSVG ? 1 : svg.w / svg.vW;
    var scaleY = isPathTargetInsideSVG ? 1 : svg.h / svg.vH;
    switch(path.property){
        case 'x':
            return (p.x - svg.x) * scaleX;
        case 'y':
            return (p.y - svg.y) * scaleY;
        case 'angle':
            return Math.atan2(p1.y - p0.y, p1.x - p0.x) * 180 / Math.PI;
    }
}
// Decompose value
function decomposeValue(val, unit) {
    // const rgx = /-?\d*\.?\d+/g; // handles basic numbers
    // const rgx = /[+-]?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?/g; // handles exponents notation
    var rgx = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?/g; // handles exponents notation
    var value = validateValue(is.pth(val) ? val.totalLength : val, unit) + '';
    return {
        original: value,
        numbers: value.match(rgx) ? value.match(rgx).map(Number) : [
            0
        ],
        strings: is.str(val) || unit ? value.split(rgx) : []
    };
}
// Animatables
function parseTargets(targets) {
    var targetsArray = targets ? flattenArray(is.arr(targets) ? targets.map(toArray) : toArray(targets)) : [];
    return filterArray(targetsArray, function(item, pos, self) {
        return self.indexOf(item) === pos;
    });
}
function getAnimatables(targets) {
    var parsed = parseTargets(targets);
    return parsed.map(function(t, i) {
        return {
            target: t,
            id: i,
            total: parsed.length,
            transforms: {
                list: getElementTransforms(t)
            }
        };
    });
}
// Properties
function normalizePropertyTweens(prop, tweenSettings) {
    var settings = cloneObject(tweenSettings);
    // Override duration if easing is a spring
    if (/^spring/.test(settings.easing)) {
        settings.duration = spring(settings.easing);
    }
    if (is.arr(prop)) {
        var l = prop.length;
        var isFromTo = l === 2 && !is.obj(prop[0]);
        if (!isFromTo) {
            // Duration divided by the number of tweens
            if (!is.fnc(tweenSettings.duration)) {
                settings.duration = tweenSettings.duration / l;
            }
        } else {
            // Transform [from, to] values shorthand to a valid tween value
            prop = {
                value: prop
            };
        }
    }
    var propArray = is.arr(prop) ? prop : [
        prop
    ];
    return propArray.map(function(v, i) {
        var obj = is.obj(v) && !is.pth(v) ? v : {
            value: v
        };
        // Default delay value should only be applied to the first tween
        if (is.und(obj.delay)) {
            obj.delay = !i ? tweenSettings.delay : 0;
        }
        // Default endDelay value should only be applied to the last tween
        if (is.und(obj.endDelay)) {
            obj.endDelay = i === propArray.length - 1 ? tweenSettings.endDelay : 0;
        }
        return obj;
    }).map(function(k) {
        return mergeObjects(k, settings);
    });
}
function flattenKeyframes(keyframes) {
    var propertyNames = filterArray(flattenArray(keyframes.map(function(key) {
        return Object.keys(key);
    })), function(p) {
        return is.key(p);
    }).reduce(function(a, b) {
        if (a.indexOf(b) < 0) {
            a.push(b);
        }
        return a;
    }, []);
    var properties = {};
    var loop = function(i) {
        var propName = propertyNames[i];
        properties[propName] = keyframes.map(function(key) {
            var newKey = {};
            for(var p in key){
                if (is.key(p)) {
                    if (p == propName) {
                        newKey.value = key[p];
                    }
                } else {
                    newKey[p] = key[p];
                }
            }
            return newKey;
        });
    };
    for(var i = 0; i < propertyNames.length; i++)loop(i);
    return properties;
}
function getProperties(tweenSettings, params) {
    var properties = [];
    var keyframes = params.keyframes;
    if (keyframes) {
        params = mergeObjects(flattenKeyframes(keyframes), params);
    }
    for(var p in params){
        if (is.key(p)) {
            properties.push({
                name: p,
                tweens: normalizePropertyTweens(params[p], tweenSettings)
            });
        }
    }
    return properties;
}
// Tweens
function normalizeTweenValues(tween, animatable) {
    var t = {};
    for(var p in tween){
        var value = getFunctionValue(tween[p], animatable);
        if (is.arr(value)) {
            value = value.map(function(v) {
                return getFunctionValue(v, animatable);
            });
            if (value.length === 1) {
                value = value[0];
            }
        }
        t[p] = value;
    }
    t.duration = parseFloat(t.duration);
    t.delay = parseFloat(t.delay);
    return t;
}
function normalizeTweens(prop, animatable) {
    var previousTween;
    return prop.tweens.map(function(t) {
        var tween = normalizeTweenValues(t, animatable);
        var tweenValue = tween.value;
        var to = is.arr(tweenValue) ? tweenValue[1] : tweenValue;
        var toUnit = getUnit(to);
        var originalValue = getOriginalTargetValue(animatable.target, prop.name, toUnit, animatable);
        var previousValue = previousTween ? previousTween.to.original : originalValue;
        var from = is.arr(tweenValue) ? tweenValue[0] : previousValue;
        var fromUnit = getUnit(from) || getUnit(originalValue);
        var unit = toUnit || fromUnit;
        if (is.und(to)) {
            to = previousValue;
        }
        tween.from = decomposeValue(from, unit);
        tween.to = decomposeValue(getRelativeValue(to, from), unit);
        tween.start = previousTween ? previousTween.end : 0;
        tween.end = tween.start + tween.delay + tween.duration + tween.endDelay;
        tween.easing = parseEasings(tween.easing, tween.duration);
        tween.isPath = is.pth(tweenValue);
        tween.isPathTargetInsideSVG = tween.isPath && is.svg(animatable.target);
        tween.isColor = is.col(tween.from.original);
        if (tween.isColor) {
            tween.round = 1;
        }
        previousTween = tween;
        return tween;
    });
}
// Tween progress
var setProgressValue = {
    css: function(t, p, v) {
        return t.style[p] = v;
    },
    attribute: function(t, p, v) {
        return t.setAttribute(p, v);
    },
    object: function(t, p, v) {
        return t[p] = v;
    },
    transform: function(t, p, v, transforms, manual) {
        transforms.list.set(p, v);
        if (p === transforms.last || manual) {
            var str = '';
            transforms.list.forEach(function(value, prop) {
                str += prop + "(" + value + ") ";
            });
            t.style.transform = str;
        }
    }
};
// Set Value helper
function setTargetsValue(targets, properties) {
    var animatables = getAnimatables(targets);
    animatables.forEach(function(animatable) {
        for(var property in properties){
            var value = getFunctionValue(properties[property], animatable);
            var target = animatable.target;
            var valueUnit = getUnit(value);
            var originalValue = getOriginalTargetValue(target, property, valueUnit, animatable);
            var unit = valueUnit || getUnit(originalValue);
            var to = getRelativeValue(validateValue(value, unit), originalValue);
            var animType = getAnimationType(target, property);
            setProgressValue[animType](target, property, to, animatable.transforms, true);
        }
    });
}
// Animations
function createAnimation(animatable, prop) {
    var animType = getAnimationType(animatable.target, prop.name);
    if (animType) {
        var tweens = normalizeTweens(prop, animatable);
        var lastTween = tweens[tweens.length - 1];
        return {
            type: animType,
            property: prop.name,
            animatable: animatable,
            tweens: tweens,
            duration: lastTween.end,
            delay: tweens[0].delay,
            endDelay: lastTween.endDelay
        };
    }
}
function getAnimations(animatables, properties) {
    return filterArray(flattenArray(animatables.map(function(animatable) {
        return properties.map(function(prop) {
            return createAnimation(animatable, prop);
        });
    })), function(a) {
        return !is.und(a);
    });
}
// Create Instance
function getInstanceTimings(animations, tweenSettings) {
    var animLength = animations.length;
    var getTlOffset = function(anim) {
        return anim.timelineOffset ? anim.timelineOffset : 0;
    };
    var timings = {};
    timings.duration = animLength ? Math.max.apply(Math, animations.map(function(anim) {
        return getTlOffset(anim) + anim.duration;
    })) : tweenSettings.duration;
    timings.delay = animLength ? Math.min.apply(Math, animations.map(function(anim) {
        return getTlOffset(anim) + anim.delay;
    })) : tweenSettings.delay;
    timings.endDelay = animLength ? timings.duration - Math.max.apply(Math, animations.map(function(anim) {
        return getTlOffset(anim) + anim.duration - anim.endDelay;
    })) : tweenSettings.endDelay;
    return timings;
}
var instanceID = 0;
function createNewInstance(params) {
    var instanceSettings = replaceObjectProps(defaultInstanceSettings, params);
    var tweenSettings = replaceObjectProps(defaultTweenSettings, params);
    var properties = getProperties(tweenSettings, params);
    var animatables = getAnimatables(params.targets);
    var animations = getAnimations(animatables, properties);
    var timings = getInstanceTimings(animations, tweenSettings);
    var id = instanceID;
    instanceID++;
    return mergeObjects(instanceSettings, {
        id: id,
        children: [],
        animatables: animatables,
        animations: animations,
        duration: timings.duration,
        delay: timings.delay,
        endDelay: timings.endDelay
    });
}
// Core
var activeInstances = [];
var engine = function() {
    var raf;
    function play() {
        if (!raf && (!isDocumentHidden() || !anime.suspendWhenDocumentHidden) && activeInstances.length > 0) {
            raf = requestAnimationFrame(step);
        }
    }
    function step(t) {
        // memo on algorithm issue:
        // dangerous iteration over mutable `activeInstances`
        // (that collection may be updated from within callbacks of `tick`-ed animation instances)
        var activeInstancesLength = activeInstances.length;
        var i = 0;
        while(i < activeInstancesLength){
            var activeInstance = activeInstances[i];
            if (!activeInstance.paused) {
                activeInstance.tick(t);
                i++;
            } else {
                activeInstances.splice(i, 1);
                activeInstancesLength--;
            }
        }
        raf = i > 0 ? requestAnimationFrame(step) : undefined;
    }
    function handleVisibilityChange() {
        if (!anime.suspendWhenDocumentHidden) {
            return;
        }
        if (isDocumentHidden()) {
            // suspend ticks
            raf = cancelAnimationFrame(raf);
        } else {
            // first adjust animations to consider the time that ticks were suspended
            activeInstances.forEach(function(instance) {
                return instance._onDocumentVisibility();
            });
            engine();
        }
    }
    if (typeof document !== 'undefined') {
        document.addEventListener('visibilitychange', handleVisibilityChange);
    }
    return play;
}();
function isDocumentHidden() {
    return !!document && document.hidden;
}
// Public Instance
function anime(params) {
    if (params === void 0) params = {};
    var startTime = 0, lastTime = 0, now = 0;
    var children, childrenLength = 0;
    var resolve = null;
    function makePromise(instance) {
        var promise = window.Promise && new Promise(function(_resolve) {
            return resolve = _resolve;
        });
        instance.finished = promise;
        return promise;
    }
    var instance = createNewInstance(params);
    var promise = makePromise(instance);
    function toggleInstanceDirection() {
        var direction = instance.direction;
        if (direction !== 'alternate') {
            instance.direction = direction !== 'normal' ? 'normal' : 'reverse';
        }
        instance.reversed = !instance.reversed;
        children.forEach(function(child) {
            return child.reversed = instance.reversed;
        });
    }
    function adjustTime(time) {
        return instance.reversed ? instance.duration - time : time;
    }
    function resetTime() {
        startTime = 0;
        lastTime = adjustTime(instance.currentTime) * (1 / anime.speed);
    }
    function seekChild(time, child) {
        if (child) {
            child.seek(time - child.timelineOffset);
        }
    }
    function syncInstanceChildren(time) {
        if (!instance.reversePlayback) {
            for(var i = 0; i < childrenLength; i++){
                seekChild(time, children[i]);
            }
        } else {
            for(var i$1 = childrenLength; i$1--;){
                seekChild(time, children[i$1]);
            }
        }
    }
    function setAnimationsProgress(insTime) {
        var i = 0;
        var animations = instance.animations;
        var animationsLength = animations.length;
        while(i < animationsLength){
            var anim = animations[i];
            var animatable = anim.animatable;
            var tweens = anim.tweens;
            var tweenLength = tweens.length - 1;
            var tween = tweens[tweenLength];
            // Only check for keyframes if there is more than one tween
            if (tweenLength) {
                tween = filterArray(tweens, function(t) {
                    return insTime < t.end;
                })[0] || tween;
            }
            var elapsed = minMax(insTime - tween.start - tween.delay, 0, tween.duration) / tween.duration;
            var eased = isNaN(elapsed) ? 1 : tween.easing(elapsed);
            var strings = tween.to.strings;
            var round = tween.round;
            var numbers = [];
            var toNumbersLength = tween.to.numbers.length;
            var progress = void 0;
            for(var n = 0; n < toNumbersLength; n++){
                var value = void 0;
                var toNumber = tween.to.numbers[n];
                var fromNumber = tween.from.numbers[n] || 0;
                if (!tween.isPath) {
                    value = fromNumber + eased * (toNumber - fromNumber);
                } else {
                    value = getPathProgress(tween.value, eased * toNumber, tween.isPathTargetInsideSVG);
                }
                if (round) {
                    if (!(tween.isColor && n > 2)) {
                        value = Math.round(value * round) / round;
                    }
                }
                numbers.push(value);
            }
            // Manual Array.reduce for better performances
            var stringsLength = strings.length;
            if (!stringsLength) {
                progress = numbers[0];
            } else {
                progress = strings[0];
                for(var s = 0; s < stringsLength; s++){
                    var a = strings[s];
                    var b = strings[s + 1];
                    var n$1 = numbers[s];
                    if (!isNaN(n$1)) {
                        if (!b) {
                            progress += n$1 + ' ';
                        } else {
                            progress += n$1 + b;
                        }
                    }
                }
            }
            setProgressValue[anim.type](animatable.target, anim.property, progress, animatable.transforms);
            anim.currentValue = progress;
            i++;
        }
    }
    function setCallback(cb) {
        if (instance[cb] && !instance.passThrough) {
            instance[cb](instance);
        }
    }
    function countIteration() {
        if (instance.remaining && instance.remaining !== true) {
            instance.remaining--;
        }
    }
    function setInstanceProgress(engineTime) {
        var insDuration = instance.duration;
        var insDelay = instance.delay;
        var insEndDelay = insDuration - instance.endDelay;
        var insTime = adjustTime(engineTime);
        instance.progress = minMax(insTime / insDuration * 100, 0, 100);
        instance.reversePlayback = insTime < instance.currentTime;
        if (children) {
            syncInstanceChildren(insTime);
        }
        if (!instance.began && instance.currentTime > 0) {
            instance.began = true;
            setCallback('begin');
        }
        if (!instance.loopBegan && instance.currentTime > 0) {
            instance.loopBegan = true;
            setCallback('loopBegin');
        }
        if (insTime <= insDelay && instance.currentTime !== 0) {
            setAnimationsProgress(0);
        }
        if (insTime >= insEndDelay && instance.currentTime !== insDuration || !insDuration) {
            setAnimationsProgress(insDuration);
        }
        if (insTime > insDelay && insTime < insEndDelay) {
            if (!instance.changeBegan) {
                instance.changeBegan = true;
                instance.changeCompleted = false;
                setCallback('changeBegin');
            }
            setCallback('change');
            setAnimationsProgress(insTime);
        } else {
            if (instance.changeBegan) {
                instance.changeCompleted = true;
                instance.changeBegan = false;
                setCallback('changeComplete');
            }
        }
        instance.currentTime = minMax(insTime, 0, insDuration);
        if (instance.began) {
            setCallback('update');
        }
        if (engineTime >= insDuration) {
            lastTime = 0;
            countIteration();
            if (!instance.remaining) {
                instance.paused = true;
                if (!instance.completed) {
                    instance.completed = true;
                    setCallback('loopComplete');
                    setCallback('complete');
                    if (!instance.passThrough && 'Promise' in window) {
                        resolve();
                        promise = makePromise(instance);
                    }
                }
            } else {
                startTime = now;
                setCallback('loopComplete');
                instance.loopBegan = false;
                if (instance.direction === 'alternate') {
                    toggleInstanceDirection();
                }
            }
        }
    }
    instance.reset = function() {
        var direction = instance.direction;
        instance.passThrough = false;
        instance.currentTime = 0;
        instance.progress = 0;
        instance.paused = true;
        instance.began = false;
        instance.loopBegan = false;
        instance.changeBegan = false;
        instance.completed = false;
        instance.changeCompleted = false;
        instance.reversePlayback = false;
        instance.reversed = direction === 'reverse';
        instance.remaining = instance.loop;
        children = instance.children;
        childrenLength = children.length;
        for(var i = childrenLength; i--;){
            instance.children[i].reset();
        }
        if (instance.reversed && instance.loop !== true || direction === 'alternate' && instance.loop === 1) {
            instance.remaining++;
        }
        setAnimationsProgress(instance.reversed ? instance.duration : 0);
    };
    // internal method (for engine) to adjust animation timings before restoring engine ticks (rAF)
    instance._onDocumentVisibility = resetTime;
    // Set Value helper
    instance.set = function(targets, properties) {
        setTargetsValue(targets, properties);
        return instance;
    };
    instance.tick = function(t) {
        now = t;
        if (!startTime) {
            startTime = now;
        }
        setInstanceProgress((now + (lastTime - startTime)) * anime.speed);
    };
    instance.seek = function(time) {
        setInstanceProgress(adjustTime(time));
    };
    instance.pause = function() {
        instance.paused = true;
        resetTime();
    };
    instance.play = function() {
        if (!instance.paused) {
            return;
        }
        if (instance.completed) {
            instance.reset();
        }
        instance.paused = false;
        activeInstances.push(instance);
        resetTime();
        engine();
    };
    instance.reverse = function() {
        toggleInstanceDirection();
        instance.completed = instance.reversed ? false : true;
        resetTime();
    };
    instance.restart = function() {
        instance.reset();
        instance.play();
    };
    instance.remove = function(targets) {
        var targetsArray = parseTargets(targets);
        removeTargetsFromInstance(targetsArray, instance);
    };
    instance.reset();
    if (instance.autoplay) {
        instance.play();
    }
    return instance;
}
// Remove targets from animation
function removeTargetsFromAnimations(targetsArray, animations) {
    for(var a = animations.length; a--;){
        if (arrayContains(targetsArray, animations[a].animatable.target)) {
            animations.splice(a, 1);
        }
    }
}
function removeTargetsFromInstance(targetsArray, instance) {
    var animations = instance.animations;
    var children = instance.children;
    removeTargetsFromAnimations(targetsArray, animations);
    for(var c = children.length; c--;){
        var child = children[c];
        var childAnimations = child.animations;
        removeTargetsFromAnimations(targetsArray, childAnimations);
        if (!childAnimations.length && !child.children.length) {
            children.splice(c, 1);
        }
    }
    if (!animations.length && !children.length) {
        instance.pause();
    }
}
function removeTargetsFromActiveInstances(targets) {
    var targetsArray = parseTargets(targets);
    for(var i = activeInstances.length; i--;){
        var instance = activeInstances[i];
        removeTargetsFromInstance(targetsArray, instance);
    }
}
// Stagger helpers
function stagger(val, params) {
    if (params === void 0) params = {};
    var direction = params.direction || 'normal';
    var easing = params.easing ? parseEasings(params.easing) : null;
    var grid = params.grid;
    var axis = params.axis;
    var fromIndex = params.from || 0;
    var fromFirst = fromIndex === 'first';
    var fromCenter = fromIndex === 'center';
    var fromLast = fromIndex === 'last';
    var isRange = is.arr(val);
    var val1 = isRange ? parseFloat(val[0]) : parseFloat(val);
    var val2 = isRange ? parseFloat(val[1]) : 0;
    var unit = getUnit(isRange ? val[1] : val) || 0;
    var start = params.start || 0 + (isRange ? val1 : 0);
    var values = [];
    var maxValue = 0;
    return function(el, i, t) {
        if (fromFirst) {
            fromIndex = 0;
        }
        if (fromCenter) {
            fromIndex = (t - 1) / 2;
        }
        if (fromLast) {
            fromIndex = t - 1;
        }
        if (!values.length) {
            for(var index = 0; index < t; index++){
                if (!grid) {
                    values.push(Math.abs(fromIndex - index));
                } else {
                    var fromX = !fromCenter ? fromIndex % grid[0] : (grid[0] - 1) / 2;
                    var fromY = !fromCenter ? Math.floor(fromIndex / grid[0]) : (grid[1] - 1) / 2;
                    var toX = index % grid[0];
                    var toY = Math.floor(index / grid[0]);
                    var distanceX = fromX - toX;
                    var distanceY = fromY - toY;
                    var value = Math.sqrt(distanceX * distanceX + distanceY * distanceY);
                    if (axis === 'x') {
                        value = -distanceX;
                    }
                    if (axis === 'y') {
                        value = -distanceY;
                    }
                    values.push(value);
                }
                maxValue = Math.max.apply(Math, values);
            }
            if (easing) {
                values = values.map(function(val) {
                    return easing(val / maxValue) * maxValue;
                });
            }
            if (direction === 'reverse') {
                values = values.map(function(val) {
                    return axis ? val < 0 ? val * -1 : -val : Math.abs(maxValue - val);
                });
            }
        }
        var spacing = isRange ? (val2 - val1) / maxValue : val1;
        return start + spacing * (Math.round(values[i] * 100) / 100) + unit;
    };
}
// Timeline
function timeline(params) {
    if (params === void 0) params = {};
    var tl = anime(params);
    tl.duration = 0;
    tl.add = function(instanceParams, timelineOffset) {
        var tlIndex = activeInstances.indexOf(tl);
        var children = tl.children;
        if (tlIndex > -1) {
            activeInstances.splice(tlIndex, 1);
        }
        function passThrough(ins) {
            ins.passThrough = true;
        }
        for(var i = 0; i < children.length; i++){
            passThrough(children[i]);
        }
        var insParams = mergeObjects(instanceParams, replaceObjectProps(defaultTweenSettings, params));
        insParams.targets = insParams.targets || params.targets;
        var tlDuration = tl.duration;
        insParams.autoplay = false;
        insParams.direction = tl.direction;
        insParams.timelineOffset = is.und(timelineOffset) ? tlDuration : getRelativeValue(timelineOffset, tlDuration);
        passThrough(tl);
        tl.seek(insParams.timelineOffset);
        var ins = anime(insParams);
        passThrough(ins);
        children.push(ins);
        var timings = getInstanceTimings(children, params);
        tl.delay = timings.delay;
        tl.endDelay = timings.endDelay;
        tl.duration = timings.duration;
        tl.seek(0);
        tl.reset();
        if (tl.autoplay) {
            tl.play();
        }
        return tl;
    };
    return tl;
}
anime.version = '3.2.1';
anime.speed = 1;
// TODO:#review: naming, documentation
anime.suspendWhenDocumentHidden = true;
anime.running = activeInstances;
anime.remove = removeTargetsFromActiveInstances;
anime.get = getOriginalTargetValue;
anime.set = setTargetsValue;
anime.convertPx = convertPxToUnit;
anime.path = getPath;
anime.setDashoffset = setDashoffset;
anime.stagger = stagger;
anime.timeline = timeline;
anime.easing = parseEasings;
anime.penner = penner;
anime.random = function(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
};
const __TURBOPACK__default__export__ = anime;
}}),
"[project]/node_modules/next/navigation.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
module.exports = __turbopack_require__("[project]/node_modules/next/dist/client/components/navigation.js [app-client] (ecmascript)");
}}),
"[project]/node_modules/bezier-easing/src/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
/**
 * https://github.com/gre/bezier-easing
 * BezierEasing - use bezier curve for transition easing function
 * by Gaëtan Renaudeau 2014 - 2015 – MIT License
 */ // These values are established by empiricism with tests (tradeoff: performance VS precision)
var NEWTON_ITERATIONS = 4;
var NEWTON_MIN_SLOPE = 0.001;
var SUBDIVISION_PRECISION = 0.0000001;
var SUBDIVISION_MAX_ITERATIONS = 10;
var kSplineTableSize = 11;
var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);
var float32ArraySupported = typeof Float32Array === 'function';
function A(aA1, aA2) {
    return 1.0 - 3.0 * aA2 + 3.0 * aA1;
}
function B(aA1, aA2) {
    return 3.0 * aA2 - 6.0 * aA1;
}
function C(aA1) {
    return 3.0 * aA1;
}
// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.
function calcBezier(aT, aA1, aA2) {
    return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
}
// Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.
function getSlope(aT, aA1, aA2) {
    return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
}
function binarySubdivide(aX, aA, aB, mX1, mX2) {
    var currentX, currentT, i = 0;
    do {
        currentT = aA + (aB - aA) / 2.0;
        currentX = calcBezier(currentT, mX1, mX2) - aX;
        if (currentX > 0.0) {
            aB = currentT;
        } else {
            aA = currentT;
        }
    }while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS)
    return currentT;
}
function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
    for(var i = 0; i < NEWTON_ITERATIONS; ++i){
        var currentSlope = getSlope(aGuessT, mX1, mX2);
        if (currentSlope === 0.0) {
            return aGuessT;
        }
        var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
        aGuessT -= currentX / currentSlope;
    }
    return aGuessT;
}
function LinearEasing(x) {
    return x;
}
module.exports = function bezier(mX1, mY1, mX2, mY2) {
    if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {
        throw new Error('bezier x values must be in [0, 1] range');
    }
    if (mX1 === mY1 && mX2 === mY2) {
        return LinearEasing;
    }
    // Precompute samples table
    var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
    for(var i = 0; i < kSplineTableSize; ++i){
        sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
    }
    function getTForX(aX) {
        var intervalStart = 0.0;
        var currentSample = 1;
        var lastSample = kSplineTableSize - 1;
        for(; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample){
            intervalStart += kSampleStepSize;
        }
        --currentSample;
        // Interpolate to provide an initial guess for t
        var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
        var guessForT = intervalStart + dist * kSampleStepSize;
        var initialSlope = getSlope(guessForT, mX1, mX2);
        if (initialSlope >= NEWTON_MIN_SLOPE) {
            return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
        } else if (initialSlope === 0.0) {
            return guessForT;
        } else {
            return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
        }
    }
    return function BezierEasing(x) {
        // Because JavaScript number are imprecise, we should guarantee the extremes are right.
        if (x === 0) {
            return 0;
        }
        if (x === 1) {
            return 1;
        }
        return calcBezier(getTForX(x), mY1, mY2);
    };
};
}}),
"[project]/node_modules/parallax-controller/dist/parallax-controller.esm.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "EasingPreset": (()=>EasingPreset),
    "Element": (()=>Element),
    "Limits": (()=>Limits),
    "ParallaxController": (()=>ParallaxController),
    "Rect": (()=>Rect),
    "RotationUnits": (()=>RotationUnits),
    "ScaleUnits": (()=>ScaleUnits),
    "Scroll": (()=>Scroll),
    "ScrollAxis": (()=>ScrollAxis),
    "Units": (()=>Units),
    "ValidCSSEffects": (()=>ValidCSSEffects),
    "View": (()=>View),
    "createId": (()=>createId),
    "getProgressAmount": (()=>getProgressAmount),
    "isElementInView": (()=>isElementInView),
    "parseElementTransitionEffects": (()=>parseElementTransitionEffects),
    "parseValueAndUnit": (()=>parseValueAndUnit),
    "resetStyles": (()=>resetStyles),
    "scaleBetween": (()=>scaleBetween),
    "scaleEffectByProgress": (()=>scaleEffectByProgress),
    "setElementStyles": (()=>setElementStyles),
    "testForPassiveScroll": (()=>testForPassiveScroll)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bezier$2d$easing$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/bezier-easing/src/index.js [app-client] (ecmascript)");
;
var Limits = function Limits(properties) {
    this.startX = properties.startX;
    this.startY = properties.startY;
    this.endX = properties.endX;
    this.endY = properties.endY; // Used to calculate the progress of the element
    this.totalX = this.endX - this.startX;
    this.totalY = this.endY - this.startY; // Used to scale translate effects
    this.startMultiplierX = properties.startMultiplierX || 1;
    this.endMultiplierX = properties.endMultiplierX || 1;
    this.startMultiplierY = properties.startMultiplierY || 1;
    this.endMultiplierY = properties.endMultiplierY || 1;
};
function _extends() {
    _extends = Object.assign || function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
var ValidCSSEffects;
(function(ValidCSSEffects) {
    ValidCSSEffects["speed"] = "speed";
    ValidCSSEffects["translateX"] = "translateX";
    ValidCSSEffects["translateY"] = "translateY";
    ValidCSSEffects["rotate"] = "rotate";
    ValidCSSEffects["rotateX"] = "rotateX";
    ValidCSSEffects["rotateY"] = "rotateY";
    ValidCSSEffects["rotateZ"] = "rotateZ";
    ValidCSSEffects["scale"] = "scale";
    ValidCSSEffects["scaleX"] = "scaleX";
    ValidCSSEffects["scaleY"] = "scaleY";
    ValidCSSEffects["scaleZ"] = "scaleZ";
    ValidCSSEffects["opacity"] = "opacity";
})(ValidCSSEffects || (ValidCSSEffects = {}));
var Units;
(function(Units) {
    Units["px"] = "px";
    Units["%"] = "%";
    Units["vh"] = "vh";
    Units["vw"] = "vw";
})(Units || (Units = {}));
var RotationUnits;
(function(RotationUnits) {
    RotationUnits["deg"] = "deg";
    RotationUnits["turn"] = "turn";
    RotationUnits["rad"] = "rad";
})(RotationUnits || (RotationUnits = {}));
var ScaleUnits;
(function(ScaleUnits) {
    ScaleUnits[""] = "";
})(ScaleUnits || (ScaleUnits = {}));
var ScrollAxis;
(function(ScrollAxis) {
    ScrollAxis["vertical"] = "vertical";
    ScrollAxis["horizontal"] = "horizontal";
})(ScrollAxis || (ScrollAxis = {}));
var EasingPreset;
(function(EasingPreset) {
    EasingPreset["ease"] = "ease";
    EasingPreset["easeIn"] = "easeIn";
    EasingPreset["easeOut"] = "easeOut";
    EasingPreset["easeInOut"] = "easeInOut";
    EasingPreset["easeInQuad"] = "easeInQuad";
    EasingPreset["easeInCubic"] = "easeInCubic";
    EasingPreset["easeInQuart"] = "easeInQuart";
    EasingPreset["easeInQuint"] = "easeInQuint";
    EasingPreset["easeInSine"] = "easeInSine";
    EasingPreset["easeInExpo"] = "easeInExpo";
    EasingPreset["easeInCirc"] = "easeInCirc";
    EasingPreset["easeOutQuad"] = "easeOutQuad";
    EasingPreset["easeOutCubic"] = "easeOutCubic";
    EasingPreset["easeOutQuart"] = "easeOutQuart";
    EasingPreset["easeOutQuint"] = "easeOutQuint";
    EasingPreset["easeOutSine"] = "easeOutSine";
    EasingPreset["easeOutExpo"] = "easeOutExpo";
    EasingPreset["easeOutCirc"] = "easeOutCirc";
    EasingPreset["easeInOutQuad"] = "easeInOutQuad";
    EasingPreset["easeInOutCubic"] = "easeInOutCubic";
    EasingPreset["easeInOutQuart"] = "easeInOutQuart";
    EasingPreset["easeInOutQuint"] = "easeInOutQuint";
    EasingPreset["easeInOutSine"] = "easeInOutSine";
    EasingPreset["easeInOutExpo"] = "easeInOutExpo";
    EasingPreset["easeInOutCirc"] = "easeInOutCirc";
    EasingPreset["easeInBack"] = "easeInBack";
    EasingPreset["easeOutBack"] = "easeOutBack";
    EasingPreset["easeInOutBack"] = "easeInOutBack";
})(EasingPreset || (EasingPreset = {}));
/**
 * Creates a unique id to distinguish parallax elements.
 */ var id = 0;
function createId() {
    ++id;
    return id;
}
var Rect = /*#__PURE__*/ function() {
    function Rect(options) {
        var rect = options.el.getBoundingClientRect(); // rect is based on viewport -- must adjust for relative scroll container
        if (options.view.scrollContainer) {
            var scrollRect = options.view.scrollContainer.getBoundingClientRect();
            rect = _extends({}, rect, {
                top: rect.top - scrollRect.top,
                right: rect.right - scrollRect.left,
                bottom: rect.bottom - scrollRect.top,
                left: rect.left - scrollRect.left
            });
        }
        this.height = options.el.offsetHeight;
        this.width = options.el.offsetWidth;
        this.left = rect.left;
        this.right = rect.right;
        this.top = rect.top;
        this.bottom = rect.bottom;
        if (options.rootMargin) {
            this._setRectWithRootMargin(options.rootMargin);
        }
    }
    /**
   * Apply root margin to all properties
   */ var _proto = Rect.prototype;
    _proto._setRectWithRootMargin = function _setRectWithRootMargin(rootMargin) {
        var totalRootY = rootMargin.top + rootMargin.bottom;
        var totalRootX = rootMargin.left + rootMargin.right;
        this.top -= rootMargin.top;
        this.right += rootMargin.right;
        this.bottom += rootMargin.bottom;
        this.left -= rootMargin.left;
        this.height += totalRootY;
        this.width += totalRootX;
    };
    return Rect;
}();
var VALID_UNITS = [
    ScaleUnits[''],
    Units.px,
    Units['%'],
    Units['vh'],
    Units['vw'],
    RotationUnits.deg,
    RotationUnits.turn,
    RotationUnits.rad
];
/**
 * Determines the unit of a string and parses the value
 */ function parseValueAndUnit(str, defaultUnit) {
    if (defaultUnit === void 0) {
        defaultUnit = Units['%'];
    }
    var out = {
        value: 0,
        unit: defaultUnit
    };
    if (typeof str === 'undefined') return out;
    var isValid = typeof str === 'number' || typeof str === 'string';
    if (!isValid) {
        throw new Error('Invalid value provided. Must provide a value as a string or number');
    }
    str = String(str);
    out.value = parseFloat(str); // @ts-ignore
    out.unit = str.match(/[\d.\-+]*\s*(.*)/)[1] || defaultUnit; // @ts-expect-error
    var isValidUnit = VALID_UNITS.includes(out.unit);
    if (!isValidUnit) {
        throw new Error('Invalid unit provided.');
    }
    return out;
}
var easingPresets = {
    ease: [
        0.25,
        0.1,
        0.25,
        1.0
    ],
    easeIn: [
        0.42,
        0.0,
        1.0,
        1.0
    ],
    easeOut: [
        0.0,
        0.0,
        0.58,
        1.0
    ],
    easeInOut: [
        0.42,
        0.0,
        0.58,
        1.0
    ],
    /* Ease IN curves */ easeInQuad: [
        0.55,
        0.085,
        0.68,
        0.53
    ],
    easeInCubic: [
        0.55,
        0.055,
        0.675,
        0.19
    ],
    easeInQuart: [
        0.895,
        0.03,
        0.685,
        0.22
    ],
    easeInQuint: [
        0.755,
        0.05,
        0.855,
        0.06
    ],
    easeInSine: [
        0.47,
        0.0,
        0.745,
        0.715
    ],
    easeInExpo: [
        0.95,
        0.05,
        0.795,
        0.035
    ],
    easeInCirc: [
        0.6,
        0.04,
        0.98,
        0.335
    ],
    /* Ease Out Curves */ easeOutQuad: [
        0.25,
        0.46,
        0.45,
        0.94
    ],
    easeOutCubic: [
        0.215,
        0.61,
        0.355,
        1.0
    ],
    easeOutQuart: [
        0.165,
        0.84,
        0.44,
        1.0
    ],
    easeOutQuint: [
        0.23,
        1.0,
        0.32,
        1.0
    ],
    easeOutSine: [
        0.39,
        0.575,
        0.565,
        1.0
    ],
    easeOutExpo: [
        0.19,
        1.0,
        0.22,
        1.0
    ],
    easeOutCirc: [
        0.075,
        0.82,
        0.165,
        1.0
    ],
    /* Ease IN Out Curves */ easeInOutQuad: [
        0.455,
        0.03,
        0.515,
        0.955
    ],
    easeInOutCubic: [
        0.645,
        0.045,
        0.355,
        1.0
    ],
    easeInOutQuart: [
        0.77,
        0.0,
        0.175,
        1.0
    ],
    easeInOutQuint: [
        0.86,
        0.0,
        0.07,
        1.0
    ],
    easeInOutSine: [
        0.445,
        0.05,
        0.55,
        0.95
    ],
    easeInOutExpo: [
        1.0,
        0.0,
        0.0,
        1.0
    ],
    easeInOutCirc: [
        0.785,
        0.135,
        0.15,
        0.86
    ],
    /* Ease Bounce Curves */ easeInBack: [
        0.6,
        -0.28,
        0.735,
        0.045
    ],
    easeOutBack: [
        0.175,
        0.885,
        0.32,
        1.275
    ],
    easeInOutBack: [
        0.68,
        -0.55,
        0.265,
        1.55
    ]
};
function createEasingFunction(easing) {
    if (Array.isArray(easing)) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bezier$2d$easing$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(easing[0], easing[1], easing[2], easing[3]);
    }
    if (typeof easing === 'string' && typeof easingPresets[easing] !== 'undefined') {
        var params = easingPresets[easing];
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bezier$2d$easing$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(params[0], params[1], params[2], params[3]);
    }
    return;
}
var PARALLAX_EFFECTS = /*#__PURE__*/ Object.values(ValidCSSEffects);
var MAP_EFFECT_TO_DEFAULT_UNIT = {
    speed: 'px',
    translateX: '%',
    translateY: '%',
    rotate: 'deg',
    rotateX: 'deg',
    rotateY: 'deg',
    rotateZ: 'deg',
    scale: '',
    scaleX: '',
    scaleY: '',
    scaleZ: '',
    opacity: ''
};
/**
 * Takes a parallax element effects and parses the properties to get the start and end values and units.
 */ function parseElementTransitionEffects(props, scrollAxis) {
    var parsedEffects = {};
    PARALLAX_EFFECTS.forEach(function(key) {
        var defaultValue = MAP_EFFECT_TO_DEFAULT_UNIT[key]; // If the provided type is a number, this must be the speed prop
        // in which case we need to construct the proper translate config
        if (typeof (props == null ? void 0 : props[key]) === 'number') {
            var value = props == null ? void 0 : props[key];
            var startSpeed = (value || 0) * 10 + "px";
            var endSpeed = (value || 0) * -10 + "px";
            var startParsed = parseValueAndUnit(startSpeed);
            var endParsed = parseValueAndUnit(endSpeed);
            var speedConfig = {
                start: startParsed.value,
                end: endParsed.value,
                unit: startParsed.unit
            }; // Manually set translate y value
            if (scrollAxis === ScrollAxis.vertical) {
                parsedEffects.translateY = speedConfig;
            } // Manually set translate y value
            if (scrollAxis === ScrollAxis.horizontal) {
                parsedEffects.translateX = speedConfig;
            }
        } // The rest are standard effect being parsed
        if (Array.isArray(props == null ? void 0 : props[key])) {
            var _value = props == null ? void 0 : props[key];
            if (typeof _value[0] !== 'undefined' && typeof _value[1] !== 'undefined') {
                var _startParsed = parseValueAndUnit(_value == null ? void 0 : _value[0], defaultValue);
                var _endParsed = parseValueAndUnit(_value == null ? void 0 : _value[1], defaultValue);
                var easing = createEasingFunction(_value == null ? void 0 : _value[2]);
                parsedEffects[key] = {
                    start: _startParsed.value,
                    end: _endParsed.value,
                    unit: _startParsed.unit,
                    easing: easing
                };
                if (_startParsed.unit !== _endParsed.unit) {
                    throw new Error('Must provide matching units for the min and max offset values of each axis.');
                }
            }
        }
    });
    return parsedEffects;
}
/**
 * Returns the percent (0 - 100) moved based on position in the viewport
 */ function getProgressAmount(/*
 * The start value from cache
 */ start, /*
 * total dist the element has to move to be 100% complete (view width/height + element width/height)
 */ totalDist, /*
 * Current scroll value
 */ currentScroll, /*
 * an optional easing function to apply
 */ easing) {
    // adjust cached value
    var startAdjustedScroll = currentScroll - start; // Amount the element has moved based on current and total distance to move
    var amount = startAdjustedScroll / totalDist; // Apply bezier easing if provided
    if (easing) {
        amount = easing(amount);
    }
    return amount;
}
/**
 * Takes two values (start, end) and returns whether the current scroll is within range
 * @param {number} start - start of scroll (x/y)
 * @param {number} end - end of scroll (x/y)
 * @param {number} scroll - current scroll (x/y)
 * @return {boolean} isInView
 */ function isElementInView(start, end, scroll) {
    var isInView = scroll >= start && scroll <= end;
    return isInView;
}
// Scale between AKA normalize
function scaleBetween(value, newMin, newMax, oldMin, oldMax) {
    return (newMax - newMin) * (value - oldMin) / (oldMax - oldMin) + newMin;
}
/**
 * Scales a start and end value of an effect based on percent moved and easing function
 */ function scaleEffectByProgress(effect, progress) {
    var value = scaleBetween(typeof effect.easing === 'function' ? effect.easing(progress) : progress, (effect == null ? void 0 : effect.start) || 0, (effect == null ? void 0 : effect.end) || 0, 0, 1);
    return {
        value: value,
        unit: effect == null ? void 0 : effect.unit
    };
}
var TRANSFORM_EFFECTS = /*#__PURE__*/ Object.values(ValidCSSEffects).filter(function(v) {
    return v !== 'opacity';
});
function setWillChangeStyles(el, effects) {
    var keys = Object.keys(effects);
    var hasOpacity = keys.includes('opacity');
    var willChange = "transform" + (hasOpacity ? ',opacity' : '');
    el.style.willChange = willChange;
}
function setElementStyles(effects, progress, el) {
    if (!el) return;
    var transform = getTransformStyles(effects, progress);
    var opacity = getOpacityStyles(effects, progress);
    el.style.transform = transform;
    el.style.opacity = opacity;
}
function getOpacityStyles(effects, progress) {
    var scaledOpacity = effects['opacity'] && scaleEffectByProgress(effects['opacity'], progress);
    if (typeof scaledOpacity === 'undefined' || typeof scaledOpacity.value === 'undefined' || typeof scaledOpacity.unit === 'undefined') {
        return '';
    }
    var styleStr = "" + scaledOpacity.value;
    return styleStr;
}
function getTransformStyles(effects, progress) {
    var transform = TRANSFORM_EFFECTS.reduce(function(acc, key) {
        var scaledEffect = effects[key] && scaleEffectByProgress(effects[key], progress);
        if (typeof scaledEffect === 'undefined' || typeof scaledEffect.value === 'undefined' || typeof scaledEffect.unit === 'undefined') {
            return acc;
        }
        var styleStr = key + "(" + scaledEffect.value + scaledEffect.unit + ")";
        return acc + styleStr;
    }, '');
    return transform;
}
/**
 * Takes a parallax element and removes parallax offset styles.
 * @param {object} element
 */ function resetStyles(element) {
    var el = element.el;
    if (!el) return;
    el.style.transform = '';
    el.style.opacity = '';
}
function createLimitsForRelativeElements(rect, view, scroll, shouldAlwaysCompleteAnimation) {
    var startY = rect.top - view.height;
    var startX = rect.left - view.width;
    var endY = rect.bottom;
    var endX = rect.right; // add scroll
    startX += scroll.x;
    endX += scroll.x;
    startY += scroll.y;
    endY += scroll.y;
    if (shouldAlwaysCompleteAnimation) {
        if (scroll.y + rect.top < view.height) {
            startY = 0;
        }
        if (scroll.x + rect.left < view.width) {
            startX = 0;
        }
        if (endY > view.scrollHeight - view.height) {
            endY = view.scrollHeight - view.height;
        }
        if (endX > view.scrollWidth - view.width) {
            endX = view.scrollWidth - view.width;
        }
    }
    var limits = new Limits({
        startX: startX,
        startY: startY,
        endX: endX,
        endY: endY
    });
    return limits;
}
function getTranslateScalar(startTranslatePx, endTranslatePx, totalDist) {
    var slow = endTranslatePx > startTranslatePx; // calculating necessary scale to increase translations
    var totalAbsOff = (Math.abs(startTranslatePx) + Math.abs(endTranslatePx)) * (slow ? -1 : 1);
    var totalDistTrue = totalDist + totalAbsOff; // Determine multiple to scale by, only values greater than 1
    var scale = Math.max(totalDist / totalDistTrue, 1);
    return scale;
}
/**
 * Return the start and end pixel values for an elements translations
 */ function getStartEndValueInPx(translate, elementSize) {
    var start = translate.start, end = translate.end, unit = translate.unit;
    if (unit === '%') {
        var scale = elementSize / 100;
        start = start * scale;
        end = end * scale;
    }
    if (unit === 'vw') {
        var startScale = start / 100;
        var endScale = end / 100;
        start = window.innerWidth * startScale;
        end = window.innerWidth * endScale;
    }
    if (unit === 'vh') {
        var _startScale = start / 100;
        var _endScale = end / 100;
        start = window.innerHeight * _startScale;
        end = window.innerHeight * _endScale;
    }
    return {
        start: start,
        end: end
    };
}
var DEFAULT_VALUE = {
    start: 0,
    end: 0,
    unit: ''
};
function createLimitsWithTranslationsForRelativeElements(rect, view, effects, scroll, scrollAxis, shouldAlwaysCompleteAnimation) {
    // get start and end accounting for percent effects
    var translateX = effects.translateX || DEFAULT_VALUE;
    var translateY = effects.translateY || DEFAULT_VALUE;
    var _getStartEndValueInPx = getStartEndValueInPx(translateX, rect.width), startTranslateXPx = _getStartEndValueInPx.start, endTranslateXPx = _getStartEndValueInPx.end;
    var _getStartEndValueInPx2 = getStartEndValueInPx(translateY, rect.height), startTranslateYPx = _getStartEndValueInPx2.start, endTranslateYPx = _getStartEndValueInPx2.end; // default starting values
    var startY = rect.top - view.height;
    var startX = rect.left - view.width;
    var endY = rect.bottom;
    var endX = rect.right;
    var startMultiplierY = 1;
    var endMultiplierY = 1;
    if (scrollAxis === ScrollAxis.vertical) {
        startMultiplierY = getTranslateScalar(startTranslateYPx, endTranslateYPx, view.height + rect.height);
        endMultiplierY = startMultiplierY;
    }
    var startMultiplierX = 1;
    var endMultiplierX = 1;
    if (scrollAxis === ScrollAxis.horizontal) {
        startMultiplierX = getTranslateScalar(startTranslateXPx, endTranslateXPx, view.width + rect.width);
        endMultiplierX = startMultiplierX;
    } // Apply the scale to initial values
    if (startTranslateYPx < 0) {
        startY = startY + startTranslateYPx * startMultiplierY;
    }
    if (endTranslateYPx > 0) {
        endY = endY + endTranslateYPx * endMultiplierY;
    }
    if (startTranslateXPx < 0) {
        startX = startX + startTranslateXPx * startMultiplierX;
    }
    if (endTranslateXPx > 0) {
        endX = endX + endTranslateXPx * endMultiplierX;
    } // add scroll
    startX += scroll.x;
    endX += scroll.x;
    startY += scroll.y;
    endY += scroll.y; // NOTE: please refactor and isolate this :(
    if (shouldAlwaysCompleteAnimation) {
        var topBeginsInView = scroll.y + rect.top < view.height;
        var leftBeginsInView = scroll.x + rect.left < view.width;
        var bottomEndsInView = scroll.y + rect.bottom > view.scrollHeight - view.height;
        var rightEndsInView = scroll.x + rect.right > view.scrollWidth - view.height;
        if (topBeginsInView && bottomEndsInView) {
            startMultiplierY = 1;
            endMultiplierY = 1;
            startY = 0;
            endY = view.scrollHeight - view.height;
        }
        if (leftBeginsInView && rightEndsInView) {
            startMultiplierX = 1;
            endMultiplierX = 1;
            startX = 0;
            endX = view.scrollWidth - view.width;
        }
        if (!topBeginsInView && bottomEndsInView) {
            startY = rect.top - view.height + scroll.y;
            endY = view.scrollHeight - view.height;
            var totalDist = endY - startY;
            startMultiplierY = getTranslateScalar(startTranslateYPx, endTranslateYPx, totalDist);
            endMultiplierY = 1;
            if (startTranslateYPx < 0) {
                startY = startY + startTranslateYPx * startMultiplierY;
            }
        }
        if (!leftBeginsInView && rightEndsInView) {
            startX = rect.left - view.width + scroll.x;
            endX = view.scrollWidth - view.width;
            var _totalDist = endX - startX;
            startMultiplierX = getTranslateScalar(startTranslateXPx, endTranslateXPx, _totalDist);
            endMultiplierX = 1;
            if (startTranslateXPx < 0) {
                startX = startX + startTranslateXPx * startMultiplierX;
            }
        }
        if (topBeginsInView && !bottomEndsInView) {
            startY = 0;
            endY = rect.bottom + scroll.y;
            var _totalDist2 = endY - startY;
            startMultiplierY = 1;
            endMultiplierY = getTranslateScalar(startTranslateYPx, endTranslateYPx, _totalDist2);
            if (endTranslateYPx > 0) {
                endY = endY + endTranslateYPx * endMultiplierY;
            }
        }
        if (leftBeginsInView && !rightEndsInView) {
            startX = 0;
            endX = rect.right + scroll.x;
            var _totalDist3 = endX - startX;
            startMultiplierX = 1;
            endMultiplierX = getTranslateScalar(startTranslateXPx, endTranslateXPx, _totalDist3);
            if (endTranslateXPx > 0) {
                endX = endX + endTranslateXPx * endMultiplierX;
            }
        }
    }
    var limits = new Limits({
        startX: startX,
        startY: startY,
        endX: endX,
        endY: endY,
        startMultiplierX: startMultiplierX,
        endMultiplierX: endMultiplierX,
        startMultiplierY: startMultiplierY,
        endMultiplierY: endMultiplierY
    });
    return limits;
}
function scaleTranslateEffectsForSlowerScroll(effects, limits) {
    var effectsCopy = _extends({}, effects);
    if (effectsCopy.translateX) {
        effectsCopy.translateX = _extends({}, effects.translateX, {
            start: effectsCopy.translateX.start * limits.startMultiplierX,
            end: effectsCopy.translateX.end * limits.endMultiplierX
        });
    }
    if (effectsCopy.translateY) {
        effectsCopy.translateY = _extends({}, effects.translateY, {
            start: effectsCopy.translateY.start * limits.startMultiplierY,
            end: effectsCopy.translateY.end * limits.endMultiplierY
        });
    }
    return effectsCopy;
}
function getShouldScaleTranslateEffects(props, effects, scrollAxis) {
    if (props.rootMargin || props.targetElement || props.shouldDisableScalingTranslations) {
        return false;
    }
    if (!!effects.translateX && scrollAxis === ScrollAxis.horizontal || !!effects.translateY && scrollAxis === ScrollAxis.vertical) {
        return true;
    }
    return false;
}
var clamp = function clamp(num, min, max) {
    return Math.min(Math.max(num, min), max);
};
var Element = /*#__PURE__*/ function() {
    function Element(options) {
        this.el = options.el;
        this.props = options.props;
        this.scrollAxis = options.scrollAxis;
        this.disabledParallaxController = options.disabledParallaxController || false;
        this.id = createId();
        this.effects = parseElementTransitionEffects(this.props, this.scrollAxis);
        this.isInView = null;
        this.progress = 0;
        this._setElementEasing(options.props.easing);
        setWillChangeStyles(options.el, this.effects);
    }
    var _proto = Element.prototype;
    _proto.updateProps = function updateProps(nextProps) {
        this.props = _extends({}, this.props, nextProps);
        this.effects = parseElementTransitionEffects(nextProps, this.scrollAxis);
        this._setElementEasing(nextProps.easing);
        return this;
    };
    _proto.setCachedAttributes = function setCachedAttributes(view, scroll) {
        // NOTE: Must reset styles before getting the rect, as it might impact the natural position
        resetStyles(this);
        this.rect = new Rect({
            el: this.props.targetElement || this.el,
            rootMargin: this.props.rootMargin,
            view: view
        });
        var shouldScaleTranslateEffects = getShouldScaleTranslateEffects(this.props, this.effects, this.scrollAxis);
        if (typeof this.props.startScroll === 'number' && typeof this.props.endScroll === 'number') {
            this.limits = new Limits({
                startX: this.props.startScroll,
                startY: this.props.startScroll,
                endX: this.props.endScroll,
                endY: this.props.endScroll
            }); // Undo the reset -- place it back at current position with styles
            this._setElementStyles();
            return this;
        }
        if (shouldScaleTranslateEffects) {
            this.limits = createLimitsWithTranslationsForRelativeElements(this.rect, view, this.effects, scroll, this.scrollAxis, this.props.shouldAlwaysCompleteAnimation);
            this.scaledEffects = scaleTranslateEffectsForSlowerScroll(this.effects, this.limits);
        } else {
            this.limits = createLimitsForRelativeElements(this.rect, view, scroll, this.props.shouldAlwaysCompleteAnimation);
        } // Undo the reset -- place it back at current position with styles
        this._setElementStyles();
        return this;
    };
    _proto._updateElementIsInView = function _updateElementIsInView(nextIsInView) {
        // NOTE: Check if this is the first change to make sure onExit isn't called
        var isFirstChange = this.isInView === null;
        if (nextIsInView !== this.isInView) {
            if (nextIsInView) {
                this.props.onEnter && this.props.onEnter(this);
            } else if (!isFirstChange) {
                this._setFinalProgress();
                this._setElementStyles();
                this.props.onExit && this.props.onExit(this);
            }
        }
        this.isInView = nextIsInView;
    };
    _proto._setFinalProgress = function _setFinalProgress() {
        var finalProgress = clamp(Math.round(this.progress), 0, 1);
        this._updateElementProgress(finalProgress);
    };
    _proto._setElementStyles = function _setElementStyles() {
        if (this.props.disabled || this.disabledParallaxController) return;
        var effects = this.scaledEffects || this.effects;
        setElementStyles(effects, this.progress, this.el);
    };
    _proto._updateElementProgress = function _updateElementProgress(nextProgress) {
        this.progress = nextProgress;
        this.props.onProgressChange && this.props.onProgressChange(this.progress);
        this.props.onChange && this.props.onChange(this);
    };
    _proto._setElementEasing = function _setElementEasing(easing) {
        this.easing = createEasingFunction(easing);
    };
    _proto.updateElementOptions = function updateElementOptions(options) {
        this.scrollAxis = options.scrollAxis;
        this.disabledParallaxController = options.disabledParallaxController || false;
    };
    _proto.updatePosition = function updatePosition(scroll) {
        if (!this.limits) return this;
        var isVertical = this.scrollAxis === ScrollAxis.vertical;
        var isFirstChange = this.isInView === null; // based on scroll axis
        var start = isVertical ? this.limits.startY : this.limits.startX;
        var end = isVertical ? this.limits.endY : this.limits.endX;
        var total = isVertical ? this.limits.totalY : this.limits.totalX;
        var s = isVertical ? scroll.y : scroll.x; // check if in view
        var nextIsInView = isElementInView(start, end, s);
        this._updateElementIsInView(nextIsInView); // set the progress if in view or this is the first change
        if (nextIsInView) {
            var nextProgress = getProgressAmount(start, total, s, this.easing);
            this._updateElementProgress(nextProgress);
            this._setElementStyles();
        } else if (isFirstChange) {
            // NOTE: this._updateElementProgress -- dont use this because it will trigger onChange
            this.progress = clamp(Math.round(getProgressAmount(start, total, s, this.easing)), 0, 1);
            this._setElementStyles();
        }
        return this;
    };
    return Element;
}();
var View = /*#__PURE__*/ function() {
    function View(config) {
        this.scrollContainer = config.scrollContainer;
        this.width = config.width;
        this.height = config.height;
        this.scrollHeight = config.scrollHeight;
        this.scrollWidth = config.scrollWidth;
    }
    var _proto = View.prototype;
    _proto.hasChanged = function hasChanged(params) {
        if (params.width !== this.width || params.height !== this.height || params.scrollWidth !== this.scrollWidth || params.scrollHeight !== this.scrollHeight) {
            return true;
        }
        return false;
    };
    _proto.setSize = function setSize(params) {
        this.width = params.width;
        this.height = params.height;
        this.scrollHeight = params.scrollHeight;
        this.scrollWidth = params.scrollWidth;
        return this;
    };
    return View;
}();
var Scroll = /*#__PURE__*/ function() {
    function Scroll(x, y) {
        this.x = x;
        this.y = y;
        this.dx = 0;
        this.dy = 0;
    }
    var _proto = Scroll.prototype;
    _proto.setScroll = function setScroll(x, y) {
        this.dx = x - this.x;
        this.dy = y - this.y;
        this.x = x;
        this.y = y;
        return this;
    };
    return Scroll;
}();
function testForPassiveScroll() {
    var supportsPassiveOption = false;
    try {
        var opts = Object.defineProperty({}, 'passive', {
            get: function get() {
                supportsPassiveOption = true;
                return true;
            }
        }); // @ts-expect-error
        window.addEventListener('test', null, opts); // @ts-expect-error
        window.removeEventListener('test', null, opts);
    } catch (e) {}
    return supportsPassiveOption;
}
/**
 * -------------------------------------------------------
 * Parallax Controller
 * -------------------------------------------------------
 *
 * The global controller for setting up and managing a scroll view of elements.
 *
 */ var ParallaxController = /*#__PURE__*/ function() {
    function ParallaxController(_ref) {
        var _ref$scrollAxis = _ref.scrollAxis, scrollAxis = _ref$scrollAxis === void 0 ? ScrollAxis.vertical : _ref$scrollAxis, scrollContainer = _ref.scrollContainer, _ref$disabled = _ref.disabled, disabled = _ref$disabled === void 0 ? false : _ref$disabled;
        this.disabled = disabled;
        this.scrollAxis = scrollAxis; // All parallax elements to be updated
        this.elements = [];
        this._hasScrollContainer = !!scrollContainer;
        this.viewEl = scrollContainer != null ? scrollContainer : window; // Scroll and View
        var _this$_getScrollPosit = this._getScrollPosition(), x = _this$_getScrollPosit[0], y = _this$_getScrollPosit[1];
        this.scroll = new Scroll(x, y);
        this.view = new View({
            width: 0,
            height: 0,
            scrollWidth: 0,
            scrollHeight: 0,
            scrollContainer: this._hasScrollContainer ? scrollContainer : undefined
        }); // Ticking
        this._ticking = false; // Passive support
        this._supportsPassive = testForPassiveScroll(); // Bind methods to class
        this._bindAllMethods(); // If this is initialized disabled, don't do anything below.
        if (this.disabled) return;
        this._addListeners(this.viewEl);
        this._addResizeObserver();
        this._setViewSize();
    }
    /**
   * Static method to instantiate the ParallaxController.
   * @returns {Class} ParallaxController
   */ ParallaxController.init = function init(options) {
        var hasWindow = typeof window !== 'undefined';
        if (!hasWindow) {
            throw new Error('Looks like ParallaxController.init() was called on the server. This method must be called on the client.');
        }
        return new ParallaxController(options);
    };
    var _proto = ParallaxController.prototype;
    _proto._bindAllMethods = function _bindAllMethods() {
        var _this = this;
        [
            '_addListeners',
            '_removeListeners',
            '_getScrollPosition',
            '_handleScroll',
            '_handleUpdateCache',
            '_updateAllElements',
            '_updateElementPosition',
            '_setViewSize',
            '_addResizeObserver',
            '_checkIfViewHasChanged',
            '_getViewParams',
            'getElements',
            'createElement',
            'removeElementById',
            'resetElementStyles',
            'updateElementPropsById',
            'update',
            'updateScrollContainer',
            'destroy'
        ].forEach(function(method) {
            // @ts-expect-error
            _this[method] = _this[method].bind(_this);
        });
    };
    _proto._addListeners = function _addListeners(el) {
        el.addEventListener('scroll', this._handleScroll, this._supportsPassive ? {
            passive: true
        } : false);
        window.addEventListener('resize', this._handleUpdateCache, false);
        window.addEventListener('blur', this._handleUpdateCache, false);
        window.addEventListener('focus', this._handleUpdateCache, false);
        window.addEventListener('load', this._handleUpdateCache, false);
    };
    _proto._removeListeners = function _removeListeners(el) {
        var _this$_resizeObserver;
        el.removeEventListener('scroll', this._handleScroll, false);
        window.removeEventListener('resize', this._handleUpdateCache, false);
        window.removeEventListener('blur', this._handleUpdateCache, false);
        window.removeEventListener('focus', this._handleUpdateCache, false);
        window.removeEventListener('load', this._handleUpdateCache, false);
        (_this$_resizeObserver = this._resizeObserver) == null ? void 0 : _this$_resizeObserver.disconnect();
    };
    _proto._addResizeObserver = function _addResizeObserver() {
        var _this2 = this;
        try {
            var observedEl = this._hasScrollContainer ? this.viewEl : document.documentElement;
            this._resizeObserver = new ResizeObserver(function() {
                return _this2.update();
            });
            this._resizeObserver.observe(observedEl);
        } catch (e) {
            console.warn('Failed to create the resize observer in the ParallaxContoller');
        }
    };
    _proto._getScrollPosition = function _getScrollPosition() {
        // Save current scroll
        // Supports IE 9 and up.
        var nx = this._hasScrollContainer ? this.viewEl.scrollLeft : window.pageXOffset;
        var ny = this._hasScrollContainer ? this.viewEl.scrollTop : window.pageYOffset;
        return [
            nx,
            ny
        ];
    } /**
   * Window scroll handler sets scroll position
   * and then calls '_updateAllElements()'.
   */ ;
    _proto._handleScroll = function _handleScroll() {
        var _this$elements;
        var _this$_getScrollPosit2 = this._getScrollPosition(), nx = _this$_getScrollPosit2[0], ny = _this$_getScrollPosit2[1];
        this.scroll.setScroll(nx, ny); // Only called if the last animation request has been
        // completed and there are parallax elements to update
        if (!this._ticking && ((_this$elements = this.elements) == null ? void 0 : _this$elements.length) > 0) {
            this._ticking = true; // @ts-ignore
            window.requestAnimationFrame(this._updateAllElements);
        }
    } /**
   * Window resize handler. Sets the new window inner height
   * then updates parallax element attributes and positions.
   */ ;
    _proto._handleUpdateCache = function _handleUpdateCache() {
        this._setViewSize();
        this._updateAllElements({
            updateCache: true
        });
    } /**
   * Update element positions.
   * Determines if the element is in view based on the cached
   * attributes, if so set the elements parallax styles.
   */ ;
    _proto._updateAllElements = function _updateAllElements(_temp) {
        var _this3 = this;
        var _ref2 = _temp === void 0 ? {} : _temp, updateCache = _ref2.updateCache;
        if (this.elements) {
            this.elements.forEach(function(element) {
                if (updateCache) {
                    element.setCachedAttributes(_this3.view, _this3.scroll);
                }
                _this3._updateElementPosition(element);
            });
        } // reset ticking so more animations can be called
        this._ticking = false;
    } /**
   * Update element positions.
   * Determines if the element is in view based on the cached
   * attributes, if so set the elements parallax styles.
   */ ;
    _proto._updateElementPosition = function _updateElementPosition(element) {
        if (element.props.disabled || this.disabled) return;
        element.updatePosition(this.scroll);
    } /**
   * Gets the params to set in the View from the scroll container or the window
   */ ;
    _proto._getViewParams = function _getViewParams() {
        if (this._hasScrollContainer) {
            // @ts-expect-error
            var _width = this.viewEl.offsetWidth; // @ts-expect-error
            var _height = this.viewEl.offsetHeight; // @ts-expect-error
            var _scrollHeight = this.viewEl.scrollHeight; // @ts-expect-error
            var _scrollWidth = this.viewEl.scrollWidth;
            return this.view.setSize({
                width: _width,
                height: _height,
                scrollHeight: _scrollHeight,
                scrollWidth: _scrollWidth
            });
        }
        var html = document.documentElement;
        var width = window.innerWidth || html.clientWidth;
        var height = window.innerHeight || html.clientHeight;
        var scrollHeight = html.scrollHeight;
        var scrollWidth = html.scrollWidth;
        return {
            width: width,
            height: height,
            scrollHeight: scrollHeight,
            scrollWidth: scrollWidth
        };
    } /**
   * Cache the view attributes
   */ ;
    _proto._setViewSize = function _setViewSize() {
        return this.view.setSize(this._getViewParams());
    } /**
   * Checks if any of the cached attributes of the view have changed.
   * @returns boolean
   */ ;
    _proto._checkIfViewHasChanged = function _checkIfViewHasChanged() {
        return this.view.hasChanged(this._getViewParams());
    } /**
   * Returns all the parallax elements in the controller
   */ ;
    _proto.getElements = function getElements() {
        return this.elements;
    } /**
   * Creates and returns new parallax element with provided options to be managed by the controller.
   */ ;
    _proto.createElement = function createElement(options) {
        var newElement = new Element(_extends({}, options, {
            scrollAxis: this.scrollAxis,
            disabledParallaxController: this.disabled
        }));
        newElement.setCachedAttributes(this.view, this.scroll);
        this.elements = this.elements ? [].concat(this.elements, [
            newElement
        ]) : [
            newElement
        ];
        this._updateElementPosition(newElement); // NOTE: This checks if the view has changed then update the controller and all elements if it has
        // This shouldn't always be necessary with a resize observer watching the view element
        // but there seems to be cases where the resize observer does not catch and update.
        if (this._checkIfViewHasChanged()) {
            this.update();
        }
        return newElement;
    } /**
   * Remove an element by id
   */ ;
    _proto.removeElementById = function removeElementById(id) {
        if (!this.elements) return;
        this.elements = this.elements.filter(function(el) {
            return el.id !== id;
        });
    } /**
   * Updates an existing parallax element object with new options.
   */ ;
    _proto.updateElementPropsById = function updateElementPropsById(id, props) {
        if (this.elements) {
            this.elements = this.elements.map(function(el) {
                if (el.id === id) {
                    return el.updateProps(props);
                }
                return el;
            });
        }
        this.update();
    } /**
   * Remove a target elements parallax styles
   */ ;
    _proto.resetElementStyles = function resetElementStyles(element) {
        resetStyles(element);
    } /**
   * Updates all cached attributes on parallax elements.
   */ ;
    _proto.update = function update() {
        // Save the latest scroll position because window.scroll
        // may be called and the handle scroll event may not be called.
        var _this$_getScrollPosit3 = this._getScrollPosition(), nx = _this$_getScrollPosit3[0], ny = _this$_getScrollPosit3[1];
        this.scroll.setScroll(nx, ny);
        this._setViewSize();
        this._updateAllElements({
            updateCache: true
        });
    } /**
   * Updates the scroll container of the parallax controller
   */ ;
    _proto.updateScrollContainer = function updateScrollContainer(el) {
        // remove existing listeners with current el first
        this._removeListeners(this.viewEl);
        this.viewEl = el;
        this._hasScrollContainer = !!el;
        this.view = new View({
            width: 0,
            height: 0,
            scrollWidth: 0,
            scrollHeight: 0,
            scrollContainer: el
        });
        this._setViewSize();
        this._addListeners(this.viewEl);
        this._updateAllElements({
            updateCache: true
        });
    };
    _proto.disableParallaxController = function disableParallaxController() {
        this.disabled = true; // remove listeners
        this._removeListeners(this.viewEl); // reset all styles
        if (this.elements) {
            this.elements.forEach(function(element) {
                return resetStyles(element);
            });
        }
    };
    _proto.enableParallaxController = function enableParallaxController() {
        var _this4 = this;
        this.disabled = false;
        if (this.elements) {
            this.elements.forEach(function(element) {
                return element.updateElementOptions({
                    disabledParallaxController: false,
                    scrollAxis: _this4.scrollAxis
                });
            });
        } // add back listeners
        this._addListeners(this.viewEl);
        this._addResizeObserver();
        this._setViewSize();
    } /**
   * Disable all parallax elements
   */ ;
    _proto.disableAllElements = function disableAllElements() {
        console.warn('deprecated: use disableParallaxController() instead');
        if (this.elements) {
            this.elements = this.elements.map(function(el) {
                return el.updateProps({
                    disabled: true
                });
            });
        }
        this.update();
    } /**
   * Enable all parallax elements
   */ ;
    _proto.enableAllElements = function enableAllElements() {
        console.warn('deprecated: use enableParallaxController() instead');
        if (this.elements) {
            this.elements = this.elements.map(function(el) {
                return el.updateProps({
                    disabled: false
                });
            });
        }
        this.update();
    } /**
   * Removes all listeners and resets all styles on managed elements.
   */ ;
    _proto.destroy = function destroy() {
        this._removeListeners(this.viewEl);
        if (this.elements) {
            this.elements.forEach(function(element) {
                return resetStyles(element);
            });
        } // @ts-expect-error
        this.elements = undefined;
    };
    return ParallaxController;
}();
;
 //# sourceMappingURL=parallax-controller.esm.js.map
}}),
"[project]/node_modules/react-scroll-parallax/dist/react-scroll-parallax.esm.js [app-client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Parallax": (()=>Parallax),
    "ParallaxBanner": (()=>ParallaxBanner),
    "ParallaxBannerLayer": (()=>ParallaxBannerLayer),
    "ParallaxContext": (()=>ParallaxContext),
    "ParallaxProvider": (()=>ParallaxProvider),
    "useParallax": (()=>useParallax),
    "useParallaxController": (()=>useParallaxController)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$parallax$2d$controller$2f$dist$2f$parallax$2d$controller$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/parallax-controller/dist/parallax-controller.esm.js [app-client] (ecmascript)");
;
;
;
function _extends() {
    _extends = Object.assign || function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for(i = 0; i < sourceKeys.length; i++){
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
    }
    return target;
}
function removeUndefinedObjectKeys(obj) {
    Object.keys(obj).forEach(function(key) {
        return obj[key] === undefined && delete obj[key];
    });
    return obj;
}
var _excluded = [
    "disabled",
    "easing",
    "endScroll",
    "onChange",
    "onEnter",
    "onExit",
    "onProgressChange",
    "opacity",
    "rootMargin",
    "rotate",
    "rotateX",
    "rotateY",
    "rotateZ",
    "scale",
    "scaleX",
    "scaleY",
    "scaleZ",
    "shouldAlwaysCompleteAnimation",
    "shouldDisableScalingTranslations",
    "speed",
    "startScroll",
    "targetElement",
    "translateX",
    "translateY"
];
function getIsolatedParallaxProps(props) {
    var disabled = props.disabled, easing = props.easing, endScroll = props.endScroll, onChange = props.onChange, onEnter = props.onEnter, onExit = props.onExit, onProgressChange = props.onProgressChange, opacity = props.opacity, rootMargin = props.rootMargin, rotate = props.rotate, rotateX = props.rotateX, rotateY = props.rotateY, rotateZ = props.rotateZ, scale = props.scale, scaleX = props.scaleX, scaleY = props.scaleY, scaleZ = props.scaleZ, shouldAlwaysCompleteAnimation = props.shouldAlwaysCompleteAnimation, shouldDisableScalingTranslations = props.shouldDisableScalingTranslations, speed = props.speed, startScroll = props.startScroll, targetElement = props.targetElement, translateX = props.translateX, translateY = props.translateY, rest = _objectWithoutPropertiesLoose(props, _excluded);
    var parallaxProps = removeUndefinedObjectKeys({
        disabled: disabled,
        easing: easing,
        endScroll: endScroll,
        onChange: onChange,
        onEnter: onEnter,
        onExit: onExit,
        onProgressChange: onProgressChange,
        opacity: opacity,
        rootMargin: rootMargin,
        rotate: rotate,
        rotateX: rotateX,
        rotateY: rotateY,
        rotateZ: rotateZ,
        scale: scale,
        scaleX: scaleX,
        scaleY: scaleY,
        scaleZ: scaleZ,
        shouldAlwaysCompleteAnimation: shouldAlwaysCompleteAnimation,
        shouldDisableScalingTranslations: shouldDisableScalingTranslations,
        speed: speed,
        startScroll: startScroll,
        targetElement: targetElement,
        translateX: translateX,
        translateY: translateY
    });
    return {
        parallaxProps: parallaxProps,
        rest: rest
    };
}
function useVerifyController(controller) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useVerifyController.useEffect": function() {
            var isServer = typeof window === 'undefined'; // Make sure the provided controller is an instance of the Parallax Controller
            var isInstance = controller instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$parallax$2d$controller$2f$dist$2f$parallax$2d$controller$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ParallaxController"]; // Throw if neither context or global is available
            if (!isServer && !controller && !isInstance) {
                throw new Error("Must wrap your application's <Parallax /> components in a <ParallaxProvider />.");
            }
        }
    }["useVerifyController.useEffect"], [
        controller
    ]);
}
var ParallaxContext = /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createContext(null);
function useParallaxController() {
    var parallaxController = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"])(ParallaxContext);
    var isServer = typeof window === 'undefined';
    if (isServer) {
        return null;
    }
    if (!parallaxController) {
        throw new Error('Could not find `react-scroll-parallax` context value. Please ensure the component is wrapped in a <ParallaxProvider>');
    }
    return parallaxController;
}
function useParallax(props) {
    var controller = useParallaxController();
    var ref = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(null);
    var _getIsolatedParallaxP = getIsolatedParallaxProps(props), parallaxProps = _getIsolatedParallaxP.parallaxProps;
    useVerifyController(controller);
    var _useState = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(), element = _useState[0], setElement = _useState[1]; // create element
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useParallax.useEffect": function() {
            var newElement;
            if (ref.current instanceof HTMLElement) {
                var options = {
                    el: ref.current,
                    props: parallaxProps
                };
                newElement = controller == null ? void 0 : controller.createElement(options);
                setElement(newElement);
            } else {
                throw new Error('You must assign the ref returned by the useParallax() hook to an HTML Element.');
            }
            return ({
                "useParallax.useEffect": function() {
                    if (newElement) {
                        controller == null ? void 0 : controller.removeElementById(newElement.id);
                    }
                }
            })["useParallax.useEffect"];
        }
    }["useParallax.useEffect"], []); // update element
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useParallax.useEffect": function() {
            if (element) {
                if (props.disabled) {
                    controller == null ? void 0 : controller.resetElementStyles(element);
                    controller == null ? void 0 : controller.updateElementPropsById(element.id, parallaxProps);
                } else {
                    controller == null ? void 0 : controller.updateElementPropsById(element.id, parallaxProps);
                }
            }
        }
    }["useParallax.useEffect"], [
        props.disabled,
        props.easing,
        props.endScroll,
        props.onChange,
        props.onEnter,
        props.onExit,
        props.onProgressChange,
        props.opacity,
        props.rootMargin,
        props.rotate,
        props.rotateX,
        props.rotateY,
        props.rotateZ,
        props.scale,
        props.scaleX,
        props.scaleY,
        props.scaleZ,
        props.shouldAlwaysCompleteAnimation,
        props.shouldDisableScalingTranslations,
        props.speed,
        props.startScroll,
        props.targetElement,
        props.translateX,
        props.translateY
    ]);
    return {
        ref: ref,
        controller: controller,
        element: element
    };
}
function Parallax(props) {
    var _getIsolatedParallaxP = getIsolatedParallaxProps(props), parallaxProps = _getIsolatedParallaxP.parallaxProps, rest = _getIsolatedParallaxP.rest;
    var _useParallax = useParallax(parallaxProps), ref = _useParallax.ref;
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("div", Object.assign({
        ref: ref
    }, rest), props.children);
}
var FALLBACK_RECT = {
    height: 0
};
function getExpandedStyle(layer) {
    if (Array.isArray(layer.translateY)) {
        var translateYStart = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$parallax$2d$controller$2f$dist$2f$parallax$2d$controller$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseValueAndUnit"])(layer.translateY[0]);
        var translateYEnd = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$parallax$2d$controller$2f$dist$2f$parallax$2d$controller$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseValueAndUnit"])(layer.translateY[1]);
        if (translateYStart.unit === 'px' && translateYEnd.unit === 'px') {
            return {
                top: Math.abs(translateYEnd.value) * -1 + "px",
                bottom: Math.abs(translateYStart.value) * -1 + "px"
            };
        }
        if (translateYStart.unit === '%' && translateYEnd.unit === '%') {
            var _layer$targetElement$, _layer$targetElement;
            var clientRect = (_layer$targetElement$ = (_layer$targetElement = layer.targetElement) == null ? void 0 : _layer$targetElement.getBoundingClientRect()) != null ? _layer$targetElement$ : FALLBACK_RECT;
            var top = Math.abs(clientRect.height * 0.01 * translateYEnd.value) * -1;
            var bottom = Math.abs(clientRect.height * 0.01 * translateYStart.value) * -1;
            return {
                top: top + "px",
                bottom: bottom + "px"
            };
        }
    }
    if (layer.speed) {
        var speed = layer.speed || 0;
        var absSpeed = Math.abs(speed) * 10 * -1;
        return {
            top: absSpeed + "px",
            bottom: absSpeed + "px"
        };
    }
    return {};
}
function getImageStyle(layer) {
    return layer.image ? {
        backgroundImage: "url(" + layer.image + ")",
        backgroundPosition: 'center',
        backgroundSize: 'cover'
    } : {};
}
var _excluded$1 = [
    "children",
    "disabled",
    "style",
    "expanded",
    "image",
    "testId"
];
var absoluteStyle = {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0
};
var ParallaxBannerLayer = function ParallaxBannerLayer(props) {
    var _getIsolatedParallaxP = getIsolatedParallaxProps(props), parallaxProps = _getIsolatedParallaxP.parallaxProps, rest = _getIsolatedParallaxP.rest;
    var style = rest.style, _rest$expanded = rest.expanded, expanded = _rest$expanded === void 0 ? true : _rest$expanded, testId = rest.testId, divProps = _objectWithoutPropertiesLoose(rest, _excluded$1);
    var imageStyle = getImageStyle(props);
    var expandedStyle = expanded ? getExpandedStyle(props) : {};
    var parallax = useParallax(_extends({
        targetElement: props.targetElement,
        shouldDisableScalingTranslations: true
    }, parallaxProps));
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("div", Object.assign({
        "data-testid": testId,
        ref: parallax.ref,
        style: _extends({}, imageStyle, absoluteStyle, expandedStyle, style)
    }, divProps), rest.children);
};
var _excluded$2 = [
    "disabled",
    "style",
    "layers"
];
var containerStyle = {
    position: 'relative',
    overflow: 'hidden',
    width: '100%'
};
var ParallaxBanner = function ParallaxBanner(props) {
    var _useState = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(null), targetElement = _useState[0], setTargetElement = _useState[1];
    var containerRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(null);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "ParallaxBanner.useEffect": function() {
            setTargetElement(containerRef.current);
        }
    }["ParallaxBanner.useEffect"], []);
    var rootStyle = props.style, _props$layers = props.layers, layers = _props$layers === void 0 ? [] : _props$layers, rootRest = _objectWithoutPropertiesLoose(props, _excluded$2);
    function renderLayers() {
        if (targetElement) {
            var shouldUseLayers = layers && layers.length > 0;
            if (shouldUseLayers) {
                return layers.map(function(layer, i) {
                    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(ParallaxBannerLayer, Object.assign({}, layer, {
                        targetElement: targetElement,
                        key: "layer-" + i,
                        testId: "layer-" + i
                    }));
                });
            }
        }
        return null;
    }
    function renderChildren() {
        if (targetElement) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Children.map(props.children, function(child) {
                var item = child; // adds the targetElement prop to any ParallaxBannerLayer components
                if ((item == null ? void 0 : item.type) === ParallaxBannerLayer) {
                    var clone = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].cloneElement(item, {
                        targetElement: targetElement
                    });
                    return clone;
                }
                return child;
            });
        }
        return null;
    }
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("div", Object.assign({
        ref: containerRef,
        style: _extends({}, containerStyle, rootStyle)
    }, rootRest), renderLayers(), renderChildren());
};
var createController = function createController(options) {
    // Don't initialize on the server
    var isServer = typeof window === 'undefined';
    if (!isServer) {
        // Must not be the server so kick it off...
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$parallax$2d$controller$2f$dist$2f$parallax$2d$controller$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ParallaxController"].init(options);
    }
    return null;
};
function ParallaxProvider(props) {
    var controller = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(null);
    if (!controller.current) {
        controller.current = createController({
            scrollAxis: props.scrollAxis || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$parallax$2d$controller$2f$dist$2f$parallax$2d$controller$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScrollAxis"].vertical,
            scrollContainer: props.scrollContainer,
            disabled: props.isDisabled
        });
    } // update scroll container
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "ParallaxProvider.useEffect": function() {
            if (props.scrollContainer && controller.current) {
                controller.current.updateScrollContainer(props.scrollContainer);
            }
        }
    }["ParallaxProvider.useEffect"], [
        props.scrollContainer,
        controller.current
    ]); // disable/enable parallax
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "ParallaxProvider.useEffect": function() {
            if (props.isDisabled && controller.current) {
                controller.current.disableParallaxController();
            }
            if (!props.isDisabled && controller.current) {
                controller.current.enableParallaxController();
            }
        }
    }["ParallaxProvider.useEffect"], [
        props.isDisabled,
        controller.current
    ]); // remove the controller when unmounting
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "ParallaxProvider.useEffect": function() {
            return ({
                "ParallaxProvider.useEffect": function() {
                    (controller == null ? void 0 : controller.current) && (controller == null ? void 0 : controller.current.destroy());
                }
            })["ParallaxProvider.useEffect"];
        }
    }["ParallaxProvider.useEffect"], []);
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(ParallaxContext.Provider, {
        value: controller.current
    }, props.children);
}
;
 //# sourceMappingURL=react-scroll-parallax.esm.js.map
}}),
"[project]/node_modules/react-scroll-parallax/dist/react-scroll-parallax.esm.js [app-client] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$parallax$2d$controller$2f$dist$2f$parallax$2d$controller$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/parallax-controller/dist/parallax-controller.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$scroll$2d$parallax$2f$dist$2f$react$2d$scroll$2d$parallax$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/react-scroll-parallax/dist/react-scroll-parallax.esm.js [app-client] (ecmascript) <locals>");
}}),
}]);

//# sourceMappingURL=node_modules_2d131b._.js.map